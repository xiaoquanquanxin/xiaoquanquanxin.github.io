{
    "title": "ES6",
    "description": "es6总结",
    "indexList": [
        {
            "title": "let和const命令"
        }
    ],
    "sectionList": [
        {
            "title": "let和const命令",
            "__html": "<ol>\n    <li>不能重复声明</li>\n    <li>没有变量声明提升</li>\n    <li>存在暂时死区</li>\n    <li>有块级作用域</li>\n</ol>\n<h4>const</h4>\n<ol>\n    <li>必须第一时间赋值</li>\n    <li>不能重复赋值</li>\n</ol>\n<h4>顶级作用域</h4>\n<ol>\n    <li>es5中,顶级作用域在不同环境中不同</li>\n    <li>window作为顶级作用域,可以在任何位置读写,不利于模块化编程,容易声明出错,编译不会第一时间报错</li>\n</ol>",
            "code": "{\n    let a = 1;\n}\n//相当于\n(function () {\n    var a = 1;\n}());\n\n\n//so\nlet arr = [];\nfor (let i = 0; i < 3; i++) {\n    arr[i] = function () {\n        console.log(i);\n    }\n}\nconsole.log(arr);\n//相当于\n(function () {\n    var arr = [];\n    for (var i = 0; i < 3; i++) {\n        (function (a) {\n            arr[a] = function () {\n                console.log(a);\n            };\n        }(i));\n    }\n    console.log(arr);\n    console.log(arr[1]());\n}());\n\n//不存在变量声明提升\n//使用let声明变量时，只要变量在还没有声明完成前使用，就会报错,产生暂时性死区.\n//对一个没有被let声明的变量使用typeof操作符,反而不会报错\n\n//应该避免在块级作用域内声明函数。[考虑到环境导致的行为差异太大]\n//如果确实需要，也应该写成函数表达式，而不是函数声明语句。\nif (1) {\n    let f = function () {\n    };\n}\n\n\n//let 总结\n//不会声明提升\n//不能重复声明\n//存在暂时死区\n//有块级作用域\n\n//const 总结\n//必须第一时间赋值\n//不能再次赋值\n\n//const本质\n//const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。\n//对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。\n//const指向一个地址,这个地址保存一个指针,这个指针的指向是固定的地址,被指向的数据结构却不能控制"
        },
        {
            "title": "解构赋值",
            "__html": "<h3>解构赋值</h3>\n<ol>\n    <li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</li>\n    <li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li>\n    <li>对于对象的解构赋值,诸如'let { foo: abc, bar: def } = { foo: \"aaa\", bar: \"bbb\" };'这样的写法,对象的解构赋值的内部机制， <span class=\"red\">是先找到同名属性，然后再赋给对应的变量</span>。真正被赋值的是值，而不是键。\n    </li>\n    <li>但是给声明后的变量赋值时,需要用小括号. {x} = {x: 1}; 第一个{x}会被识别为代码块而报错</li>\n    <li>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</li>\n</ol>\n<hr>\n<p>疑问</p>\n<h3>不建议使用括号</h3>\n<a href=\"http://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/destructuring#%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E5%9C%86%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%83%85%E5%86%B5\">不能使用小括号的情况</a>\n<br>\n<a href=\"http://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/destructuring#%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%9C%86%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%83%85%E5%86%B5\">能够使用小括号的情况</a>\n",
            "code": "\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n{\n    var _ref = ['a'],\n        x = _ref[0],\n        y = _ref[1],\n        z = _ref.slice(2);\n\n    x; // \"a\"\n    y; // undefined\n    z; // []\n}\n{\n    var _ref2 = new Set(['a', 'b', 'c']),\n        _ref3 = _slicedToArray(_ref2, 3),\n        _x = _ref3[0],\n        _y = _ref3[1],\n        _z = _ref3[2];\n\n    _x; // \"a\"\n}\n{\n    var _ref4 = [2],\n        _ref4$ = _ref4[0],\n        _x2 = _ref4$ === undefined ? 1 : _ref4$,\n        _ref4$2 = _ref4[1],\n        _y2 = _ref4$2 === undefined ? _x2 : _ref4$2; // x=2; y=2\n\n}\n{\n    var obj = { first: 'hello', last: 'world' };\n    var james = obj.first,\n        l = obj.last;\n\n    james; // 'hello'\n    l; // 'world'\n}\n{\n    var _obj = {\n        p: ['Hello', { y: 'World' }]\n    };\n\n    var _james = _obj.p,\n        _obj$p = _slicedToArray(_obj.p, 2),\n        _x3 = _obj$p[0],\n        _y3 = _obj$p[1].y;\n    //x;// \"Hello\"\n    //y;// \"World\"\n\n\n    console.log(_james); // [\"Hello\", {y: \"World\"}]\n}\n{\n    var node = {\n        loc: {\n            start: {\n                line: 1,\n                column: 5\n            }\n        }\n    };\n    var loc = node.loc,\n        start = node.loc.start,\n        line = node.loc.start.line;\n}\n{\n    var log = Math.log,\n        sin = Math.sin,\n        cos = Math.cos;\n}\n{\n    var arr = [1, 2, 3];\n    var first = arr[0],\n        last = arr[arr.length - 1],\n        middle = arr[1];\n\n    console.log(first);\n    console.log(middle);\n    console.log(last);\n}\n//函数参数解构\n{\n    var _arr = [[1, 2], [3, 4]].map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            a = _ref6[0],\n            b = _ref6[1];\n\n        return a + b;\n    });\n    console.log(_arr);\n}\n//为x和y这两个函数参数的属性设置默认值\n{\n    var move = function move() {\n        var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref7$x = _ref7.x,\n            x = _ref7$x === undefined ? 0 : _ref7$x,\n            _ref7$y = _ref7.y,\n            y = _ref7$y === undefined ? 0 : _ref7$y;\n\n        return [x, y];\n    };\n}\n//为函数的参数设置默认值而不是x和y\n{\n    var _move = function _move() {\n        var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { x: 0, y: 0 },\n            x = _ref8.x,\n            y = _ref8.y;\n\n        return [x, y];\n    };\n}\n//总结\n//给谁设置默认值直接给谁加=号\n\n{\n    var _x6 = { x: 'ncaa' };\n    ncaa = _x6.x;\n\n    console.log(ncaa);\n}\n//可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n{\n    // 正确\n    b = 3;\n    // 正确\n    var _ref9 = {};\n    d = _ref9.p;\n    // 正确\n    var _ref10 = [3];\n    parseInt.prop = _ref10[0];\n    console.log(parseInt.prop);\n}"
        },
        {
            "title": "字符串的扩展",
            "__html": "<h3>字符串的扩展</h3>\n<ol>\n    <li>如果unicode字符超过0xffff的数值,需要两个/u来拼接,es6改进为\\u{xxxxx}</li>\n    <li>ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点,10进制数。</li>\n    <li>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</li>\n    <li>字符串的遍历器接口使用for of</li>\n    <li>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</li>\n    <li>includes,包含某个字符.</li>\n    <li>endsWidth,表示参数字符串是否在原字符串的尾部.第二个参数表示截取字符串结束的下标.</li>\n    <li>startsWith,表示参数字符串是否在原字符串的头部.</li>\n    <li>repeat,重复,参数取整,不可<-1,字符串参数先转为数字</li>\n    <li><a href=\"http://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/string#padStart%EF%BC%8CpadEnd\">padStart,endStart用于补全字符串</a>\n    </li>\n</ol>",
            "code": "//  识别大于\\uffff的字\n{\n    let s = '\uD842\uDFB7a';\n    s.codePointAt(0).toString(16);// \"20bb7\"\n    s.codePointAt(2).toString(16); // \"61\"\n}\n\n//  转换为大于\\uffff的字\n{\n    String.fromCodePoint(0x20BB7);  //吉\n}\n//  字符串for of遍历可以识别大于\\uffff的字\n{\n    for (let x of String.fromCodePoint(0x22222) + 11) {\n        console.log(x)\n    }\n}\n//  unicode正规化\n{\n    console.log('\\u01D1'.normalize() === '\\u004F\\u030C'.normalize());\n}\n\n//  参数表示开始搜索的位置\n{\n    let s = 'hello';\n    s.includes('h');\n    s.endsWith('e', 2);\n    s.startsWith('h');\n}\n//  重复,参数取整,不可<-1,字符串参数先转为数字\n{\n    let s = 'ncaa';\n    s.repeat(2);\n    s.repeat('0.2');        //  ''\n}\n//  如果某个字符串不够指定长度，会在头部或尾部补全。\n{\n    let x = 'x';\n    x.padStart(5, 'ab'); // 'ababx'\n    x.padStart(4, 'ab'); // 'abax'\n\n    x.padEnd(5, 'ab'); // 'xabab'\n    x.padEnd(4, 'ab'); // 'xaba'\n}\n//  如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串\n{\n    'xxx'.padStart(1, 'ab');    // 'xxx'\n}\n//  模板字符串\n{\n    const tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n}"
        },
        {
            "title": "数值的扩展",
            "__html": "<h3>Number方法</h3>\n<ol>\n    <li>二进制和八进制表示法,0b和0o</li>\n    <li>Number.isFinite只识别真正的有效数字为true.</li>\n    <li>Number.isNaN只有NaN是true.</li>\n    <li>Number.isInteger判断是否为整数</li>\n    <li>Number.isSafeInteger安全整数.JavaScript 能够准确表示的<span class=\"red\">整数</span>范围在-2^53到2^53之间.</li>\n</ol>\n<h3>Math方法</h3>\n<ol>\n    <li>Math.trunc先转数字型,再去掉小数部分</li>\n    <li>Math.sign判断数字正负值,非数字为NaN</li>\n    <li>Math.cbrt立方根</li>\n    <li>Math.clz32返回一个数的32位无符号二进制整数形式有多少个前导零,先转为数字类型</li>\n    <li>Math.imul乘法</li>\n    <li>Math.fround方法返回一个数的32位单精度浮点数形式。</li>\n    <li>Math.hypot方法返回所有参数的平方和的平方根。</li>\n</ol>"
        },
        {
            "title": "函数的扩展",
            "__html": "\n<h3>函数的扩展</h3>\n<ol>\n    <li>函数的length属性,等于传入的第一个被赋予默认值的参数的index,即(a,b=2,c)等于b的下标1</li>\n    <li>函数的length属性,不包括 rest 参数。</li>\n    <li>作用域,外层作用域>形参作用域>函数体作用域</li>\n    <li>可以将参数默认值设为undefined,表明这个参数是可以省略的。(a = undefined)</li>\n    <li>rest 参数之后不能再有其他参数（即只能是最后一个参数）,否则会报错。(...a,b)</li>\n    <li>函数参数使用了默认值、解构赋值、或者rest参数,那么函数内部就不能显式设定为严格模式.</li>\n</ol>\n<h4>箭头函数使用注意点</h4>\n<ol>\n    <li>函数体内的this对象,总是指向箭头函数定义生效时所在的对象[箭头函数绑定的内部属性],而不是使用时所在的对象.实际上,箭头函数没有this,他的this是上一级函数作用域的this.</li>\n    <li>不可以当作构造函数,不可以使用new命令符执行.</li>\n    <li>不可以使用arguments对象,应使用rest扩展运算符代替.</li>\n    <li>不可以当做Generator函数,不能使用yield命令.</li>\n    <li>另外,如果函数体很复杂,不单纯是为了计算值,不应该使用箭头函数.而是要使用普通函数,提高代码可读性.</li>\n</ol>\n<h4>双冒号运算符[只是提案]</h4>\n<ol>\n    <li>bar::foo;相当于foo.bind(bar);</li>\n    <li>解释:函数绑定运算符是并排的两个冒号（::）,双冒号左边是一个对象,右边是一个函数。该运算符会自动将左边的对象,作为上下文环境（即this对象）,绑定到右边的函数上面。</li>\n</ol>\n<h4>尾调用优化</h4>\n<ol>\n    <li>概念:某个函数的最后一步是调用另一个函数</li>\n    <li>在函数调用时,会在内存中形成一个'调用记录',又称'调用帧',保存调用位置和内部变量等信息.</li>\n    <li>函数调用自身,叫做递归,在函数结尾调用自身,叫做尾递归</li>\n    <li>递归非常耗费内存,因为需要同时保存成千上百个调用帧,很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说,由于只存在一个调用帧,所以永远不会发生“栈溢出”错误。</li>\n    <li>尾递归的实现,需要把所有用到的内部变量改写成函数的参数</li>\n    <li>柯里化:将多参数的函数转化成单参数的函数</li>\n</ol>\n<p>\n    新写法的函数,或者箭头函数，{a(){},b:()=>{})，都不能被new，但是赋值给变量之后可以被new的。\n    新写法的函数有自己的this，箭头函数没有自己的this。\n</p>",
            "code": "//  函数参数默认值\n{\n    log = (a = 12) => a++;\n    let a = log();\n}\n//  作用域\n{\n    //实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。\n    //  形参自成作用域\n    var x = 1;\n\n    //function foo(x = x) {\n    function foo(x = 1) {\n        // ...\n    }\n\n    foo(); // ReferenceError: x is not defined\n}\n//  作用域\n{\n    let foo = '外';\n\n    function bar(func = () => foo) {\n        (() => {\n            let foo = '内';\n            console.log(func())\n        })();\n    }\n\n    bar();\n}\n\n{\n    var x = 1;\n\n    //  y里面的x先指向同级作用域的x\n    function foo(x, y = function () {\n        x = 2;\n    }) {\n        //let x = 3;\n        var x = 3;\n        y();\n        console.log(x);\n    }\n\n    foo() // 3\n    x // 1\n}\n//  函数参数默认值的应用\n{\n    function throwIfMissing() {\n        throw new Error('Missing parameter');\n    }\n\n    function foo(mustBeProvided = throwIfMissing()) {\n        return mustBeProvided;\n    }\n\n    foo(1);// Error: Missing paramete\n}\n//...rest\n{\n    function sortNumbers() {\n        return Array.prototype.slice.call(arguments).sort();\n    }\n\n    //相当于\n    const mySortNumbers = (...numbers) => (numbers.sort());\n    //numbers是arguments的纯数组形式\n}\n//  函数的length属性，不包括 rest 参数,rest参数也不能设置默认值\n{\n    foo = (a = 1, ...b) => {\n    };\n    foo.length = 0;\n}\n//  es6函数参数如果使用了扩展运算符rest,解构,默认值,则在函数体内不能使用'use strict';\n{\n    const doSomething = (function () {\n        'use strict';\n        return function (value = 42) {\n            return value;\n        };\n    }());\n}\n//  name指向这个函数的名字,bind返回的函数,name属性前缀为bound\n{\n    (function () {\n    }).bind(null).name;\n    (function james() {\n    }).bind(null).name;\n}\n//  箭头函数=>\n{\n\n}\n//  不需要返回值\n{\n    //let fn = () => void doesNotReturn();\n    //fn()\n}\n//  如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。\n{\n    const fn = () => {\n        ;\n        ;\n        return;\n    }\n}\n/**\n * 箭头函数注意点\n * **/\n//  this的指向\n{\n    function Timer() {\n        this.s1 = 0;\n        this.s2 = 0;\n        // 箭头函数\n        setTimeout(() => {\n            this.s1++;\n            console.log(this);\n        }, 9);\n        // 普通函数\n        setTimeout(function () {\n            console.log(this)\n            this.s2++;\n        }, 9);\n    }\n\n    var timer = new Timer();\n    //timer.s1  = 0; 每个1秒以后+1\n    //window.s2 = NaN;\n\n    setTimeout(() => console.log('s1: ', timer.s1), 10);\n    setTimeout(() => console.log('s2: ', timer.s2), 10);\n}\n//  例子  只有真正的function才能绑定this,箭头函数没有自己的this,他永远指向定义该函数时的函数作用域\n//  除了this,arguments、super、new.target也指向外层函数的对应变量.\n{\n    function foo() {\n        var _this = this;\n        return () => {\n            console.log(this);\n            return () => {\n                return () => {\n                    console.log('id:', this.id);\n                    console.log(_this === this);\n                };\n            };\n        };\n    }\n\n    var f = foo.call({id: 1});\n    var t0 = f()()();\n    var t1 = f.call({id: 2})()();       //  箭头函数没有自己的this,所以这个call的object没法绑定,所以this指向最外层的foo函数的this\n    var t2 = f().call({id: 3})();\n    var t3 = f()().call({id: 4});\n}\n//  call,apply,bind等无法改变箭头函数中this的指向\n{\n    function foo() {\n        //  这个箭头函数里的this是函数foo里的this,相当于window,而且无法并bind绑定\n        return (() => this.alert).bind({\n            alert: function () {\n                return 'alert'\n            }\n        });\n    }\n\n    function fooo() {\n        return (function () {\n            return this.alert\n        }).bind({\n            alert: function () {\n                return 'alert'\n            }\n        });\n    }\n\n    let f = foo();\n    //f()();\n}\n\n//  箭头函数使this从动态指向变成静态指向,下面的场合不应该使用this\n{\n    const cat = {\n        lives: 9,\n        jumps: () => {\n            this.lives--;\n        }\n    }\n}\n\n//  箭头函数的嵌套函数\n{\n    function insert(value) {\n        return {\n            into: function (array) {\n                return {\n                    after: function (afterValue) {\n                        array.splice(array.indexOf(afterValue) + 1, 0, value);\n                        return array;\n                    }\n                };\n            }\n        };\n    }\n\n    insert(2).into([1, 3]).after(1);\n}\n{\n    let insert = (value) => ({\n        into: (array) => ({\n            after: (afterValue) => {\n                array.splice(array.indexOf(afterValue) + 1, 0, value);\n                return array\n            }\n        })\n    })\n    insert(2).into([1, 3]).after(1);\n}\n\n//  箭头函数的嵌套\n{\n    const pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);\n    const plus1 = a => a + 1;\n    const mult2 = a => a * 2;\n    const addThenMult = pipeline(plus1, mult2);\n    addThenMult(5)\n}\n{\n    const pipeline = function (...funcs) {\n        return function (val) {\n            return funcs.reduce(function (a, b) {\n                return b(a)\n            }, val);\n        }\n    };\n    const plus1 = function (a) {\n        return a + 1;\n    };\n    const mult2 = function (a) {\n        return a * 2;\n    };\n    const addThenMult = pipeline(plus1, mult2);\n    let res = addThenMult(5);\n    console.log(res);\n}\n{\n    const pipeline = function (...funcs) {\n        return function (value) {\n            return funcs.reduce(function (a, b) {\n                return b(a);\n            }, value)\n        }\n    };\n    const fn = pipeline(function (a) {\n        return a + 1;\n    }, function (a) {\n        return a * 2;\n    }, function (a) {\n        return a - 3;\n    }, function (a) {\n        return a / 4;\n    });\n    let res = fn(10);\n    console.log(res);\n}\n{\n    const pipeline = (...funcs) => (value) => funcs.reduce((a, b) => b(a), value);\n    const fn = pipeline(function (a) {\n        return a + 1;\n    }, function (a) {\n        return a * 2;\n    }, function (a) {\n        return a - 3;\n    }, function (a) {\n        return a / 4;\n    });\n    let res = fn(10);\n    console.log(res);\n}\n//  双冒号运算符\n{\n    let bar = {};\n    let foo = () => {\n\n    };\n    //bar::foo;\n}\n\n//  尾调用优化\n//  尾递归可以只保留一个调用帧,而非尾递归的递归需要保留无数调用帧\n//  非尾递归形式\n{\n    const factorial = (a) => {\n        if (a < 1) {\n            return 0\n        }\n        return a + factorial(a - 1);\n    };\n    factorial(5)\n}\n//  尾递归形式\n{\n    const factorial = (a, b = 0) => {\n        if (a < 1) {\n            return b;\n        }\n        return factorial(a - 1, b + a);\n    };\n    factorial(10);\n}\n//  非尾递归形式\n{\n    const fibonacci = (x) => {\n        if (x < 1) {\n            return 1;\n        }\n        return fibonacci(x - 2) + fibonacci(x - 1);\n    };\n    fibonacci(5);\n}\n//  尾递归形式\n{\n    const fibonacci = (x, a = 1, b = 1) => {\n        if (x < 3) {\n            return b;\n        }\n        return fibonacci(x - 1, b, a + b);\n    };\n    fibonacci(12);\n}\n//  柯里化阶乘\n{\n    const jie = (fn, n) => {\n        return (val) => {\n            return fn(val, n);\n        }\n    };\n    const fn = (val, n) => {\n        if (val < 1) {\n            return n;\n        }\n        return fn(val - 1, n * val)\n    };\n    const ff = jie(fn, 1);\n    ff(7);\n}\n"
        },
        {
            "title": "数组的扩展",
            "__html": "<h3>数组的扩展</h3>\n<ol>\n    <li>扩展运算符,相当于rest参数的逆运算.合并数组,赋值数组,替代函数的 apply 方法,解构字符串.</li>\n    <li>Array.from,将两类对象转换成真正的数组.1.类数组对象[扩展运算符不能转换],2.可遍历对象iterator.</li>\n    <li>Array.of,解决new Array传入数字参数的不确定性.</li>\n    <li>copyWithin,以第二个参数为数组下标处的值为起点,第三个参数为终点,将这部分内容赋值给第一个参数为下标处的位置.覆盖操作.</li>\n    <li>find,第一个参数是函数参数,找出第一个符合条件的成员\\undefined.第二个参数是绑定的this.findIndex,返回下标.</li>\n    <li>fill,填充给定值.后两个参数是起止点.</li>\n    <li>includes,是否包含.</li>\n    <li>flat,将数组拉伸成一个一维数组.flatMap,接受一个函数参数,让每个成员执行函数,并拉伸数组.</li>\n    <li>keys,values,entries返回一个遍历器对象.</li>\n</ol>\n<h4>规则</h4>\n<ol>\n    <li>所有的空位都识别为undefined.</li>\n</ol>",
            "code": "//  扩展运算符\n//  展开数组,相当于rest参数的逆运算\n{\n    console.log(...[1, 2, 3]);\n    console.log(1, ...[2, 3, 4], 5);\n    console.log([...document.querySelectorAll('*')]);\n    const c = (...x) => {\n        console.log(...x);\n        console.log(x)\n    };\n    c(1, ...[2, 3, 4], 5);\n}\n//  替代函数的 apply 方法\n{\n    let arr = [1, 2, 3, 4, 5];\n    Math.max.apply(null, arr);\n    Math.max(...arr);\n}\n//  赋值数组\n{\n    const a1 = [1, 2, {name: false}];\n    const a2 = [...a1];\n    a2.push(3);\n    a2[2].name = true;\n    console.log(a1, a2);\n}\n//  合并数组\n{\n    const a1 = [1, 2, 3];\n    const a2 = [11, 12, 13];\n    const a3 = [...a1, ...a2];\n    console.log(a3);\n}\n//  字符串\n{\n    const a1 = [...'hello'];\n    console.log(a1);\n    //能够正确识别四个字节的 Unicode 字符。\n    const a2 = [...'x\\uD83D\\uDE80y'];\n    console.log(a2);\n    console.log(a2.reverse().join(''));\n}\n\n//  Array.from(),用于将两类对象转换成真正的数组.\n//  1.类数组对象\n//  2.可遍历对象iterator\n{\n    let arrayLike = {\n        '0': 'a',\n        //'1': 'b',\n        '2': 'c',\n        length: 3\n    };\n    let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n    console.log(arr2);\n    //  Array.from还可以接受第二个函数参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n    let arr3 = Array.from(arrayLike, x => x + '16');\n    console.log(arr3);\n    //  如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。\n\n}\n//  与扩展运算符的区别\n//  任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。\n\n//  Array.of,方法用于将一组值，转换为数组,统一new Array参数为数字的不确定性\n{\n    let arr = Array.of(3);\n    console.log(arr)\n}\n\n//  copyWithin,将一部分拷贝到某处.参数:修改点,copy起始\\终止位置\n//  将起始\\终止位置处的全部作为一个整体,在修改点处覆盖一次\n{\n    let arr = [].copyWithin.call({length: 5, 3: 1}, 0, 3);\n    console.log(arr);\n}\n//  find,findIndex,找到第一个符合要求的值,下标\n{\n    [1, 23, 4, 5].find(x => x > 10);\n    [1, 23, 4, 5].findIndex(x => x > 10);\n    //  弥补indexof寻找nan的不足\n    [NaN].findIndex(y => Number.isNaN(y));\n}\n//  fill,填充一个数组\n{\n    [1, 24,].fill(4);\n    //  fill方法还可以接受第二个和第三个参数，用于指定填充的 起始位置 和 结束位置 。\n    [1, 24,].fill(4, 1);\n    //  填充的是对象,则填充引用\n    const obj = {name: '1'};\n    [1, 23, 32].fill(obj, 1);\n}\n//  entries,keys,values遍历数组.keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历\n{\n    for (let [index, elem] of ['a', 'b'].entries()) {\n        console.log(index, elem);\n    }\n    const arr = [1, 2, 3];\n    const iterator = arr.entries();\n    console.log(iterator);\n    console.log(iterator.next().value);\n    console.log(iterator.next().value);\n    console.log(iterator.next().value);\n    console.log(iterator.next().value);\n}\n//  includes,包含某元素\n{\n    [1, 2, NaN].includes(NaN);\n    //  第二个参数表示开始计数的下标,超过数组长度时,按下标为0开始计算\n    [1, 23, , 4].includes(undefined, 2);\n}\n//  数组实例的 flat()，flatMap(),将二维数组拉平为一维数组\n{\n    //  参数为拉平的层数,可以跳过空位\n    [1, 2, 3, 4, [54, 323, 3]].flat(2);\n}\n//  数组的空位,明确将空位转为undefined。\n{\n    Array.from(Array(3))[0] === undefined;\n    //  扩展运算符转为undefined\n    [...[a]] = [];\n    a === undefined;\n    //  copyWithin()会连空位一起拷贝。\n    [, , 2, 2, , 2, 2].copyWithin(1, 3, 5) === [, 2, , 2, , 2, 2];\n    //  entries,keys,values,find,findIndex\n    [1, 3, , 3, 3, , 3].findIndex(x => x === undefined);\n}"
        },
        {
            "title": "对象的扩展",
            "__html": "<h3>对象的扩展</h3>\n<ol>\n    <li>简洁表示,{foo}.</li>\n    <li>属性名表达式,{['a'+'b']}.</li>\n    <li>枚举性和遍历.</li>\n    <li>对象的扩展运算符.用于取出参数对象的所有可遍历属性,如果有取值函数get,这个函数是会执行的.</li>\n</ol>\n<h4>对象遍历属性规则:</h4>\n<h5>枚举性:</h5>\n<ol>\n    <li>for in:自身及继承的可枚举属性,唯一一个可遍历继承键.</li>\n    <li>Object.keys:自身的可枚举属性.</li>\n</ol>\n<h5>非枚举性:</h5>\n<ol>\n    <li>Object.getOwnPropertyNames:自身的全部键.</li>\n    <li>Object.getOwnPropertySymbols:自身symbol.</li>\n    <li>Reflect.ownKeys:返回自身的一切属性.</li>\n</ol>\n<p>Reflect.ownKeys的取值规则:</p>\n<ol>\n    <li>数字键从小到大</li>\n    <li>字母键按加入顺序</li>\n    <li>symbol键按加入顺序</li>\n</ol>\n<hr>\n<p>完整克隆一个对象，还拷贝对象原型的属性</p>\n<code>\n    const proto = {name: 'origin'};<br>\n    const obj = {name: 'obj', james: 'x'};<br>\n    Object.setPrototypeOf(obj, proto);<br>\n    // 写法一<br>\n    let clone = {<br>\n    '__proto__': Object.getPrototypeOf(obj), <br>\n    ...obj<br>\n    };<br>\n    <br>\n    // 写法二<br>\n    let clone1 = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);<br>\n    <br>\n    // 写法三<br>\n    // Object.create( 原型 ， 属性的描述 );<br>\n    let clone2 = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));<br>\n    console.log(Object.getOwnPropertyDescriptors(obj));<br>\n</code>",
            "code": "//  对象的扩展\n//  属性的简洁表示法\n{\n    const a = 'xxx';\n    const obj = {\n        a, getObj(x, y) {\n            return {x, y, a}\n        }\n    };\n    console.log(obj.a);\n\n    console.log(obj.getObj(11, 22));\n}\n\n//  属性名表达式\n{\n    let a = 'ncaa';\n    let obj = {\n        ['name']: 'Griffin', 'first letter': 111, [a]: a,\n    };\n    console.log(obj)\n}\n\n//  方法的 name 属性\n{\n    const key1 = Symbol('Miaoshu');\n    const obj = {\n        [key1]() {\n        }, set a(x) {\n        }, get a() {\n        }\n    };\n    //  如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。\n    const des = Object.getOwnPropertyDescriptor(obj, 'a');\n    console.log(des);\n    console.log(des.get.name);\n    //  如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。\n    console.log(obj[key1].name)\n}\n\n//  属性的可枚举性和遍历\n{\n    //  Reflect.ownKeys,返回对象自身的一切键\n    Reflect.ownKeys({});\n}\n\n//  返回一个对象属性的描述\n{\n    Object.getOwnPropertyDescriptor({}, 'name');\n    Object.getOwnPropertyDescriptors({});\n}\n//  针对Object.assign不能正确返回set,get存取器的问题\n{\n    const getSameObject = (origin) => Object.defineProperties({}, Object.getOwnPropertyDescriptors(origin));\n    const _o = {\n        set _name(x) {\n            this.name = x\n        }, get _name() {\n            return this.name\n        }\n    };\n    const obj = getSameObject(_o);\n    const asobj = Object.assign({}, _o);\n    console.log(asobj)\n}\n\n//  super指向当前对象的原型对象,只能用在对象的原型方法中\n{\n    const prot = {\n        name: 'parent', b() {\n            return this.name\n        }\n    };\n    const obj = {\n        name: 'obj', a() {\n            \"use strict\";\n            return super.name;\n        }, b() {\n            \"use strict\";\n            return super.b();\n        }\n    };\n    Object.setPrototypeOf(obj, prot);\n    console.log(obj.a());\n    //  super方法被调用相当于 Object.getPrototypeOf(this).b.call(this),故有:\n    console.log(obj.b());\n}\n\n//  解构赋值\n{\n    console.clear();\n    let proto = {\n        a: {\n            name: 'xx',\n        },\n    };\n    let obj1 = {\n        b: 2, c: 3,\n    };\n    Object.setPrototypeOf(obj1, proto);\n    let {a, b} = obj1;\n    //  直接解构继承原型属性,可以复制原型属性的引用\n    console.log(a, b);\n    //  【但是,扩展运算符的解构赋值,不能复制继承自原型对象的属性】！！！！\n    //  变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名\n    // let {...x} = obj1;\n    // console.log(x, x.a);\n}\n\n//  解构赋值\n//  完整克隆一个对象，还拷贝对象原型的属性\n{\n    const proto = {name: 'origin'};\n    const obj = {name: 'obj', james: 'x'};\n    Object.setPrototypeOf(obj, proto);\n    // 写法一\n    let clone = {\n        // '__proto__': Object.getPrototypeOf(obj), ...obj\n    };\n    console.log(clone);\n\n    // 写法二\n    let clone1 = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);\n    console.log(clone1);\n\n    // 写法三\n    //  Object.create( 原型 ， 属性的描述 );\n    let clone2 = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n    console.log(Object.getOwnPropertyDescriptors(obj));\n    console.log(clone2);\n}\n\n//  扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。\n{\n    let obj1 = {\n        get x() {\n            console.log(1)\n        }\n    }\n    let obj2 = {\n        // ...{\n        //     get x(){console.log(2)}\n        // }\n    }\n}"
        },
        {
            "title": "对象的新增方法",
            "__html": "<h3>对象的新增方法</h3>\n<ol>\n    <li>Object.is,是否相等.NaN相等,+0-0不等.</li>\n    <li>Object.assign,将第二个及以后的对象参数的属性拷贝到第一个对象参数中.</li>\n    <li>Object.getOwnPropertyDescriptors,获取对象的全部属性的属性描述,包括Symbol属性.</li>\n    <li>Object.setPrototypeOf,设置原型对象.</li>\n    <li>Object.getPrototypeOf,读取对象的原型.</li>\n    <li>Object.fromEntries,用于Object.entries的逆操作,用于讲一个键值对数组转为对象.</li>\n</ol>\n<h4>遍历方法</h4>\n<ol>\n    <li>Object.values,返回所有自身可遍历属性值.</li>\n    <li>Object.entries,返回所有自身可遍历属性键值对.</li>\n    <li>不含Symbol,不含继承.</li>\n</ol>",
            "code": "//  Object.is\n{\n    console.log(Object.is(NaN, NaN));       //  相等\n    console.log(Object.is(+0, -0));         //  不等\n    Object.isEqual = function (a, b) {\n        if (a === b) {\n            return a !== 0 || 1 / a === 1 / b;\n        }\n        return a !== a && b !== b;\n    }\n}\n\n//  Object.assign,只拷贝【自身可枚举属性以及symbol】,复制到目标对象[第一个参数]\n{\n    //第一个参数是null,或undefined的时候报错\n    let obj = Object.assign({name: 1}, undefined, [3]);\n    console.log(obj);\n    //只有字符串的包装对象，会产生可枚举属性,字符串会转成数组\n    var str = Object('abc');\n    console.log(str);\n    Object.assign(obj, 'str');\n    console.log(obj);\n    //  如果非字符串的基本数据类型作为target\n    let num = 2;\n    Object.assign(num); //  表达式的返回值是 Number{2},num === 2\n    //  assign只能进行值赋值,如果值是一个取值函数,则取出其值\n    const o = {\n        get f() {\n            return 1\n        }\n    };\n    Object.assign(obj, o);\n    console.log(obj);\n}\n//  作用\n{\n    //1.指定默认值\n    const Default = {a: 1, b: 1};\n    const obj1 = Object.assign({}, Default, {b: 2});\n    console.log(obj1);\n    //2.克隆对象\n    const obj2 = Object.assign({}, Default, Object.getPrototypeOf(Default));\n    console.log(obj2);\n}\n\n//  Object.getOwnPropertyDescriptors , 返回指定对象所有自身属性及Symbol（非继承属性）的描述对象。\n{\n    const obj1 = {name: 1, getOwn: 'getOwnPropertyDescriptors', [Symbol()]: 123};\n    const des1 = Object.getOwnPropertyDescriptors(obj1);\n    console.log(des1);\n}\n//  Object.getOwnPropertyDescriptor实现Object.getOwnPropertyDescriptors\n//  主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。\n{\n    function getOwnPropertyDescriptors(obj) {\n        var _obj = {};\n        Reflect.ownKeys(obj).forEach(function (t, i) {\n            _obj[t] = Object.getOwnPropertyDescriptor(obj, t);\n        });\n        return _obj;\n    }\n\n    const a = {name: 1};\n    Object.defineProperty(a, 'n', {\n        enumerable: true, get() {\n            return this.name\n        }, set(x) {\n            this.name = x\n        }\n    });\n    const b = getOwnPropertyDescriptors(a);\n    console.log(a);\n    console.log(b);\n}\n//  实现对属性的完全拷贝\n{\n    function copy(origin) {\n        const obj = {};\n        Reflect.ownKeys(origin).map(function (t, i) {\n            Object.defineProperty(obj, t, Object.getOwnPropertyDescriptor(origin, t));\n        });\n        return obj;\n    }\n\n    const a = Object.defineProperty({}, 'name', {\n        get() {\n            \"use strict\";\n            return this.n;\n        }, set(x) {\n            \"use strict\";\n            this.n = x;\n        }\n    });\n    a.name = 12;\n    const b = copy(a);\n    console.log(b);\n    console.log(Object.getOwnPropertyDescriptor(b, 'name'));\n\n    //  简单实现\n    copy1 = (origin) => Object.defineProperties({}, Object.getOwnPropertyDescriptors(origin));\n\n    const c = copy1(b);\n    console.log(c);\n}\n\n//  Object.setPrototypeOf,Object.getPrototypeOf\n{\n    //   ES6 正式推荐的设置原型对象的方法\n    const proto = {name: 1};\n    const obj = Object.setPrototypeOf({}, proto);\n    console.log(obj);\n}\n\n//  Object.keys,Object.values,Object.entries\n{\n    //  Object.keys, 返回自身所有可枚举属性,不含symbol,不含继承\n    //  遍历顺序即 数字,字母加入的顺序\n    const {keys, values, entries} = Object;\n    const obj = {a: 1, c: 3, b: 2, [Symbol()]: 'symbol', \"1\": 'james'};\n    for (let key of keys(obj)) {\n        console.log(key);\n    }\n    for (let value of values(obj)) {\n        console.log(value);\n    }\n    for (let [key, value] of entries(obj)) {\n        console.log(key, value);\n    }\n    console.log(keys('123456'));\n    console.log(values('123456'));\n    console.log(entries('123456'));\n}\n\n//  Object.fromEntries 是 Object.entries的逆运算\n{\n    Object.fromEntries = Object.fromEntries || function (arr) {\n        const obj = {};\n        arr.forEach(function (t, i) {\n            obj[t[0]] = t[1]\n        });\n        return obj;\n    };\n    let obj = Object.fromEntries([['foo', 'bar'], ['baz', 42]]);\n    console.log(obj);\n}\n"
        },
        {
            "title": "Symbol",
            "__html": "<h3>Symbol</h3>\n<ol>\n    <li>一种新的原始数据类型Symbol,表示独一无二的值.</li>\n    <li>Symbol通过Symbol函数生成一个原始数据类型的值,而不是一个对象.</li>\n    <li>如果Symbol的description是一个对象,则会调用对象的toString方法.</li>\n    <li>Symbol值不能与其他类型的值进行运算,会报错.</li>\n    <li>Symbol可以转为字符串和布尔,不能转为数字.</li>\n</ol>\n<h3>作为属性的Symbol</h3>\n<ol>\n    <li>能保证不会出现同名属性.</li>\n    <li>防止某一个键不小心被覆盖.</li>\n    <li>不能用点运算符访问,应该用方括号访问.</li>\n</ol>\n<h3>实例:消除魔术字符串</h3>\n<h5>魔术字符串是在代码中多次出现的,形成强耦合的字符串.</h5>\n<ol>\n    <li>常用方法:将它写成一个变量.</li>\n    <li>这个变量的值是什么,并不重要,所以很适合Symbol值.</li>\n</ol>\n<h3>属性名的遍历</h3>\n<ol>\n    <li>Object.getOwnPropertySymbols,可以获取对象中所有的Symbol属性名.</li>\n    <li>Reflect.ownKeys,返回所有键名.</li>\n</ol>\n<h3>其他Symbol方法</h3>\n<ol>\n    <li>Symbol.for,Symbol函数会永远新建一个值.Symbol.for先会检查给定的key是否注册过一次,如果不存在才会新建一个值.</li>\n    <li>Symbol.keyFor,返回一个已登记的Symbol类型的key,仅对Symbol.for注册的值有效.</li>\n</ol>\n<h3>内置的Symbol值</h3>\n<h5>均是在调用某些方法或执行某些操作的时候会调用.</h5>\n<ol>\n    <li>Symbol.iterator,指向对象的默认遍历器方法.对象进行for...of循环时,会调用Symbol.iterator方法.</li>\n    <li>Symbol.hasInstance,指向一个内部方法,当其他对象使用instanceof运算符时,会调用这个方法.</li>\n    <li>Symbol.isConcatSpreadable,等于一个布尔值,控制当调用Array.prototype.concat方法时,是否可以展开数组.</li>\n    <li>Symbol.species,执行一个构造函数,创建衍生对象时,会使用该属性.</li>\n    <li>Symbol.match,指向一个函数,当执行str.match(myObject)时,如果该属性存在,会调用它,返回该方法的返回值.</li>\n    <li>Symbol.replace,Symbol.search,Symbol.split,类似.</li>\n    <li>Symbol.toPrimitive,指向一个方法,该对象被转为原始类型的值时调用该方法.接受一个字符串参数,表示当前的运算模式,[Number,String,Default].</li>\n    <li>\n        Symbol.toStringTag,指向一个值描述value或存取器get,在对象调用Object.prototype.toString方法时,它的值可以出现在Object.prototype.toString方法返回的字符串中.所以它可以定制Object.prototype.toString方法返回的字符串.\n    </li>\n    <li>Symbol.unscopables,指向一个对象,制定了使用with关键字时,那些属性会被with环境排除.</li>\n\n</ol>",
            "code": "//  作为属性名的Symbol\n{\n    //  Symbol 值作为对象属性名时，不能用点运算符。\n    let s = Symbol('mySymbol');\n    let obj = {[s]: 'xxx'};\n    console.log(obj[s]);\n}\n\n//  遍历\n{\n    let obj = {name: 1};\n    obj[Symbol()] = 123;\n    let ops = Object.getOwnPropertySymbols(obj);\n    console.log(ops);\n\n    //  Reflect.ownKeys 返回对象的各种类型属性集合\n    let oks = Reflect.ownKeys(obj);\n    console.log(oks);\n}\n\n//  重新使用同一个 Symbol 值\n{\n    let a = Symbol('xx');\n    let b = Symbol.for('xx');\n    let c = Symbol.for('xx');\n    console.log(a === b, b === c);\n    //  Symbol没有登记机制,每次一定是新值\n    //  Symbol.for会被登记在全局环境中,如果有已存在则返回已存在的值\n}\n\n//  Symbol.keyFor方法返回一个[已登记]的 Symbol 类型值的key。\n{\n    let a = Symbol.keyFor(Symbol('xxx'));\n    let b = Symbol.keyFor(Symbol.for('xxx'));\n    console.log(a, b);\n}\n\n\n/**\n * 内置的Symbol属性\n * */\n//  Symbol.hasInstance 指向一个内部方法.当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。\n{\n    class MyClass {\n        [Symbol.hasInstance](foo) {\n            return foo instanceof Array;\n        }\n    }\n\n    [] instanceof new MyClass();\n}\n\n//  Symbol.isConcatSpreadable 值是一个布尔值 ,表示该对象调用Array.prototype.concat的时候[是否展开]\n{\n    let a = [1, 2, 3];\n    let b = [].concat(a);\n    console.log(b);\n    a[Symbol.isConcatSpreadable] = false;\n    b = [].concat(a);\n    console.log(b);\n\n    //  类似数组的对象相反\n    let c = {length: 1, 0: 4};\n    let d = [].concat(c);\n    console.log(d);\n    c[Symbol.isConcatSpreadable] = true;\n    d = [].concat(c);\n    console.log(d);\n}\n\n//  Symbol.species 指向一个构造函数,创建衍生对象时调用\n//  实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数\n{\n    class MyArray extends Array {\n        static get [Symbol.species]() {\n            return Number;\n        }\n    }\n\n    let a = new MyArray();\n    let b = a.map(function () {\n    });\n    console.log(b instanceof MyArray, b instanceof Array, b instanceof Number, a, b);\n}\n/**\n * 其他类似,调用对象的某个方法时会调用[Symbol.xx]的方法\n */\n"
        },
        {
            "title": "Set和Map数据结构",
            "__html": "<h3>Set和Map数据结构</h3>\n<h4>Set</h4>\n<ol>\n    <li>类似于数组,但成员的值都是唯一的.</li>\n    <li>实例具有iterator接口.</li>\n    <li>Set本身是一个构造函数,用来生成Set数据结构.</li>\n</ol>\n<h5>实例属性和方法:</h5>\n<ol>\n    <li>size:相当于数组的length.</li>\n    <li>constructor:指向构造函数.</li>\n    <li>add:添加某个成员,返回实例.</li>\n    <li>delete:删除某个成员,返回布尔值,表示成功还是失败.</li>\n    <li>has:是否包含某个成员,返回布尔值.</li>\n    <li>clear:删除全部成员.</li>\n    <li>实例的遍历操作:keys,values,entries,forEach.</li>\n    <li>Set的遍历顺序就是插入顺序.</li>\n</ol>\n<h4>WeakSet</h4>\n<ol>\n    <li>也是不重复的值的集合.</li>\n    <li>WeakSet的成员只能是对象.</li>\n    <li>WeakSet中的对象是弱引用,垃圾回收机制不考虑这个对象是否存在于WeakSet中.</li>\n    <li>不支持遍历:垃圾回收机制不记录WeakSet中的引用,而垃圾回收机制的运行时间也不确定,所以WeakSet的值的个数不确定.</li>\n</ol>\n<h5>与垃圾回收机制的关系:</h5>\n<ol>\n    <li>垃圾回收机制会定期检查对象是否需要被清理.</li>\n    <li>如果某个值被使用后没有被清除,就会造成内存泄漏.</li>\n    <li>WeakSet里面的引用都是弱引用,不会被垃圾回收机制记录为被引用,所以可能会被清除.</li>\n    <li>只要这些对象在外部消失,它在WeakSet里面的引用也会消失.</li>\n</ol>\n<h5>实例属性和方法:</h5>\n<ol>\n    <li>add,has,delete,同Set.</li>\n</ol>\n<h4>Map</h4>\n<ol>\n    <li>类似于对象,但传统对象只能用字符作为键,而Map可以以对象作为键.</li>\n</ol>\n<h5>实例属性和方法:</h5>\n<ol>\n    <li>size,get,has,delete,clear同Set.</li>\n    <li>set,同Set的add.</li>\n    <li>实例的遍历方法:keys,values,entries,forEach,同Set的遍历操作.</li>\n    <li>Map的遍历顺序就是插入顺序.</li>\n</ol>\n<h5>与其他数据结构的相互转换:</h5>\n<ol>\n    <li>Map转数组:扩展运算符.</li>\n    <li>数组转Map:将数组传入Map构造函数.</li>\n    <li>Map转对象:如果所有Map的键都是字符串,它可以无损地转为对象.需要用到Object.create和for...of.</li>\n    <li>对象转Map:new Map .set.</li>\n</ol>\n<h4>WeakMap</h4>\n<ol>\n    <li class=\"red\">只接受对象作为键名,null除外,不接受其他类型.</li>\n    <li>键名指向的对象不计入垃圾回收机制.</li>\n    <li>以dom元素为键,当这个dom被移除后,这个对应的WeakMap记录也会被清除.</li>\n    <li>用于未来可能消失的对象,防止内存泄漏.</li>\n    <li>但对于值来说,还是正常引用.所以即使在外部消除了值的引用,只要键还在,还是可以访问到值.</li>\n</ol>\n<h5>实例方法:</h5>\n<ol>\n    <li>get,set,has,delete.</li>\n</ol>\n<h3>总结:</h3>\n<ol>\n    <li>Map类似于对象.Set类似于数组.</li>\n    <li>Map和Set,可以遍历,能统计size,有clear方法.</li>\n    <li>WeakMap和WeakSet均有弱引用,WeakMap对键弱引用,WeakSet对值弱引用.</li>\n    <li>WeakMap仅能接收对象键,WeakSet仅能接收对象值.</li>\n</ol>",
            "code": "//  set\n{\n    const s = new Set();\n    [1, 2, 3, 1, 2, 3].forEach(x => s.add(x));\n    console.log(s, s.size);\n    //  数组去重\n    console.log([...new Set([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7])]);\n    console.log(Array.from(new Set([1, 23, 4, 56, 1, 2, 3, 4, 5, 6])));\n    //  set认为 +0 和 -0 ，NaN和NaN相等\n}\n\n//  Set的方法包括 操作方法 和 遍历方法 两大类\n//  操作方法\n{\n    var s = new Set([1, 2, 3]);\n    s.add(4);\n    s.delete(3);\n    s.has(2);\n    s.clear();\n}\n\n//  遍历方法\n{\n    let s = new Set([3, 2, 1, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]);\n    //  Set 结构没有键名，只有键值,所以keys和values的返回值相同\n    for (let item of s.keys()) {\n        //console.log(item);\n    }\n    s.forEach(function (val, key) {\n\n    })\n}\n//  遍历的应用\n{\n    let arr = [1, , , , 2, 1, 22, 3, 31];\n    let s = new Set(arr.filter(x => x !== undefined).map(x => x * x));\n    console.log(s);\n}\n//  两个set的并集,交集,差集\n{\n    let a = new Set([1, 2, 3]);\n    let b = new Set([2, 3, 4]);\n    let c = new Set([...a, ...b]);\n    console.log('并集', c);\n    let d = new Set([...a].filter(x => b.has(x)));\n    console.log('交集', d);\n    let e = new Set([...c].filter(x => !(a.has(x) && b.has(x))));\n    console.log('差集', e);\n}\n\n\n//  WeakSet\n{\n    const ws = new WeakSet;\n    console.log(ws);\n    //  任何有Iterable接口的对象都可以作为WeakSet的参数\n    const ws1 = new WeakSet([[], [1], [3, 4]]);\n    console.log(ws1);\n}\n{\n    const b = {b: 3};\n    const arr = [b, {a: 1}];\n    const ws = new WeakSet(arr);\n    console.log(ws.has(b));\n    console.log(ws.delete(b));\n    console.log(ws.add(b));\n}\n\n\n//  Map\n{\n    const o = {n: 1};\n    const m = new Map([['key', 'value'], [o, 'j']]);\n    m.set(o, 'james');\n    console.log(m.get(o));\n    m.has(o);\n    console.log(m);\n    m.delete(o);\n}\n\n\n//  WeakMap\n//  部署私有属性。\n{\n    const _counter = new WeakMap();\n    const _action = new WeakMap();\n\n    class Countdown {\n        constructor(counter, action) {\n            _counter.set(this, counter);\n            _action.set(this, action);\n        }\n\n        dec() {\n            let counter = _counter.get(this);\n            if (counter < 1) {\n                return;\n            }\n            counter--;\n            console.log(counter);\n            _counter.set(this, counter);\n            if (counter === 0) {\n                _action.get(this)();\n            }\n        }\n    }\n\n    const c = new Countdown(3, () => console.log('DONE'));\n    c.dec();\n    c.dec();\n    c.dec();\n    c.dec();\n}\n"
        },
        {
            "title": "Proxy",
            "__html": "<h3>代理器</h3>\n<ol>\n    <li>Proxy用于修改某些操作的默认行为,等于在语言层面做出修改,所以属于一种'元编程',即对编程语言进行编程.</li>\n    <li>在目标对象之前架设一层'拦截',外界对该对象的访问,必须通过这层拦截,可以对外界的访问进行过滤和改写.</li>\n    <li class=\"red\">Proxy实际重载了点运算符,使用自己的定义覆盖了原始定义.</li>\n    <li>注意,要使得Proxy起作用,必须针对Proxy实例（上例是proxy对象）进行操作,而不是针对目标对象进行操作.</li>\n</ol>\n<h4>13种支持的拦截操作:</h4>\n<p>每一种操作都对应一个Reflect静态方法.</p>\n<ol>\n    <li><div>属性增/改:</div>set:target,key,value,receiver,用于拦截设置.</li>\n    <li><div>属性删除:</div>deleteProperty:target,key,用于拦截delete x,返回一个布尔值.</li>\n    <li><div>属性查:</div>get:target,key,receiver(接收器),用于拦截读取.</li>\n    <li><div>in操作符:</div>has:target,key,用于拦截a in b,对for...in不生效.</li>\n    <li><div>遍历:</div>ownKeys:target,拦截Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.keys,for...in循环.返回一个数组.</li>\n    <li><div>设置属性描述:</div>defineProperty:target,key,descriptor,拦截Object.definePropertyDescriptor/s,返回一个布尔值.</li>\n    <li><div>查询属性描述:</div>getOwnPropertyDescriptor:target,key,拦截Object.getOwnPropertyDescriptor,返回属性的描述对象.</li>\n    <li><div>设置对象不可拓展:</div>preventExtensions:target,拦截Object.preventExtensions,返回一个布尔值.</li>\n    <li><div>查询对象不可拓展:</div>isExtensible:target,拦截Object.isExtensible,返回一个布尔值.</li>\n    <li><div>设置对象原型:</div>setPrototypeOf:target,proto,拦截Object.preventExtensions,返回一个布尔值.</li>\n    <li><div>查询对象原型:</div>getPrototypeOf:target,拦截Object.setPrototypeOf,返回一个布尔值.</li>\n    <li><div>作为函数调用:</div>apply:target,object,args,拦截Proxy实例作为函数且被调用的操作.</li>\n    <li><div>作为构造函数调用:</div>construct:target,args,拦截Proxy实例作为构造函数且被调用的操作.</li>\n</ol>\n<h4>可取消的代理实例</h4>\n<ol>\n    <li>Proxy.revocable返回一个对象,包括一个proxy实例和一个revoke函数.</li>\n    <li>执行revoke函数后,再次操作这个proxy拦截器实例就会报错.</li>\n</ol>\n<h4>this</h4>\n<ol>\n    <li>目标对象内部的this关键字会指向Proxy代理.</li>\n</ol>",
            "code": "{\n    //  new Proxy(target, handler);\n    //  handler也是一个对象,用来定制拦截行为\n    let obj = new Proxy({count: 2}, {\n        get: function (target, key, receiver) {\n            console.log('读取', '\\n', target, key, receiver);\n            return Reflect.get(target, key, receiver);\n        }, set: function (target, key, value, receiver) {\n            console.log('设置', target, key, value, receiver);\n            return Reflect.set(target, key, value, receiver);\n        }\n    });\n    obj.count = '设置的值';\n    console.log(obj.count);\n    console.log(obj);\n}\n/**\n * Proxy 实例的方法\n */\n/***\n * get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身\n */\n{\n    function pipe(value) {\n        var funcStack = [];\n        var oproxy = new Proxy({}, {\n            get: function (pipeObject, fnName) {\n                if (fnName === 'ssss') {\n                    return funcStack.reduce(function (val, fn) {\n                        return fn(val);\n                    }, value);\n                }\n                funcStack.push(window[fnName]);\n                return oproxy;\n            }\n        });\n        return oproxy;\n    }\n\n    var double = n => n * 2;\n    var pow = n => n * n;\n    var reverseInt = n => n.toString().split(\"\").reverse().join(\"\") | 0;\n    pipe(3).double.pow.reverseInt.ssss; // 63\n}\n{\n    const dom = new Proxy({}, {\n        get(target, property) {\n            return function (attrs = {}, ...children) {\n                const el = document.createElement(property);\n                for (let prop of Object.keys(attrs)) {\n                    el.setAttribute(prop, attrs[prop]);\n                }\n                for (let child of children) {\n                    if (typeof child === 'string') {\n                        child = document.createTextNode(child);\n                    }\n                    el.appendChild(child);\n                }\n                return el;\n            }\n        }\n    });\n    //@formatter:off\n    const el = dom.div({},\n        'Hello, my name is ',\n        dom.a({href: '//example.com'}, 'Mark'),\n        '. I like:',\n        dom.ul({},\n            dom.li({}, 'The web'),\n            dom.li({}, 'Food'),\n            dom.li({}, '…actually that\\'s it')\n        ));\n    //@formatter:on\n    //document.body.appendChild(el);\n}\n{\n    const proxy = new Proxy({}, {\n        get: function (target, property, receiver) {\n            if (property === 'proxySelf') {\n                return receiver;\n            } else {\n                return target[property];\n            }\n        }\n    });\n    console.log(proxy.james === proxy);\n    console.log(proxy.proxySelf === proxy);\n}\n//  如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错\n{\n    let obj = Object.defineProperty({}, 'name', {\n        value: 'james',\n        configurable: false,\n        writable: false,\n    });\n    let proxy = new Proxy(obj, {\n        get: function (target, key, pr) {\n            console.log(target, key);\n            return 'abc';\n        }\n    });\n    try {\n        console.log(proxy.name);\n    } catch (err) {\n        //console.log(err)\n        //throw new Error('当属性的可配置性和可写性均为false时,不能通过代理修改该属性');\n    }\n}\n//  get方法可以继承。拦截操作定义在（Prototype对象）上面，所以如果读取obj对象继承的属性时，拦截会生效。\n//  （要以proxy实例为原型）\n{\n    let sup = {name: 'james'};\n    let proxy = new Proxy(sup, {\n        get: function (target, key, pr) {\n            console.log('拦截了继承的原型属性');\n            return target[key];\n        }\n    });\n    let obj = Object.create(proxy, {exp: {value: 'exp'}});\n    console.log(obj.exp);\n    console.log(obj.name);\n}\n\n/**\n * set  方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，\n * */\n{\n    const proxy = new Proxy({}, {\n        set: function (obj, prop, value, receiver) {\n            obj[prop] = receiver;\n        }\n    });\n    const myObj = {};\n    Object.setPrototypeOf(myObj, proxy);\n    myObj.foo = 'bar';\n    console.log(myObj.foo === myObj);\n}\n/**\n * defineProperty定义的对象的属性，当对象作为原型时，这个属性是可以继承的\n * */\n{\n    let sup = Object.defineProperty({}, 'name', {\n        get: function () {\n            console.log('读取原型的name');\n            return this._name;\n        },\n        set: function (val) {\n            \"use strict\";\n            console.log('设置原型的name');\n            this._name = val;\n        }\n    });\n    let obj = Object.create(sup);\n    console.log(obj.name = 1);\n    console.log(obj);\n}\n//  注意，严格模式下，set代理如果没有返回true，就会报错。\n\n\n/**\n * apply方法拦截函数的 调用、call和apply操作。\n * apply方法可以接受三个参数，分别是目标对象[这时是一个函数]、this、arguments。\n * */\n{\n    function sum(left = 0, right = 0) {\n        return left + right + (this.name || 0);\n    }\n\n    var proxy = new Proxy(sum, {\n        apply(target, _this, args) {\n            console.log(target, _this, args);\n            return Reflect.apply(...arguments) * 2;\n        }\n    });\n    let s1 = proxy(1, 2);\n    let s2 = proxy.apply({name: 1234}, []);\n    console.log(s1, s2);\n}\n\n/**\n * has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。\n * 典型的操作就是in运算符 ， 对for in 不生效。\n * */\n//  隐藏某些属性\n{\n    let sup = {_name: 'xxxx', name: 'xxxx'};\n    Object.preventExtensions(sup);\n    let proxy = new Proxy(sup, {\n        has(target, key) {\n            return true;\n            \"use strict\";\n            return key[0] !== '_' && (key in target);\n        }\n    });\n    console.log('name' in proxy);\n    console.log('james' in proxy);\n    console.log(proxy)\n}\n//  如果原（对象）不可配置或者禁止扩展，这时has拦截返回false时会报错。因为在不可配置下的对象无法隐藏属性。\n\n/**\n *construct方法用于拦截  new 命令，下面是拦截对象的写法。\n * @target 构造函数\n * @arguments 构造函数的参数\n * @newTarget 构造函数代理\n * 返回的必须是一个对象\n * */\n{\n    let proxy = new Proxy(function (arg) {\n        this.name = arg;\n    }, {\n        construct(target, arg, newTarget) {\n            \"use strict\";\n            console.log(target, arg, newTarget);\n            return {name: '没啥用啊'}\n        }\n    });\n    let p = new proxy('123456');\n    console.log(p)\n}\n\n/**\n * deleteProperty方法用于拦截delete操作.\n * 如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。\n *  如果是configurable为false的属性，则不可被拦截\n * */\n{\n    let p = new Proxy({name: 1234}, {\n        deleteProperty(target, key) {\n            \"use strict\";\n            console.log(target, key);\n            if (key === 'name') {\n                return false;\n            }\n            delete target[key]\n        }\n    });\n    delete p.name;\n    console.log(p)\n}\n\n/**\n * defineProperty\n * getOwnPropertyDescriptor\n * isExtensible 拦截  Object.isExtensible\n * */\n\n/**\n * * getPrototypeOf   拦截  继承相关事宜\n * Object.prototype.__proto__\n * Object.prototype.isPrototypeOf()\n * Object.getPrototypeOf()\n * Reflect.getPrototypeOf()\n * instanceof\n * */\n\n/**\n *ownKeys 拦截    循环相关\n *\n * Object.getOwnPropertyNames()\n * Object.getOwnPropertySymbols()\n * Object.keys()\n * for...in\n * */\n\n/**\n * preventExtensions    拦截  Object.preventExtensions()\n * 这个方法只有 Object.isExtensible 返回true ，即被封印的对象才能被调用\n * 但正常的对象的 Object.isExtensible 返回false\n * 所以要在preventExtensions里调用一次 Object.preventExtensions\n * */\n\n\n/**\n * setPrototypeOf   拦截  setPrototypeOf\n *  返回布尔值\n * */\n{\n    var handler = {\n        setPrototypeOf(target, proto) {\n            console.log('禁止拦截');\n            return true;\n            //throw new Error('禁止拦截');\n        }\n    };\n    var proto = {};\n    var proxy = new Proxy(function () {\n    }, handler);\n    Object.setPrototypeOf(proxy, proto);\n}\n\n\n/**\n * Proxy.revocable\n * Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。\n * */\n{\n    let target = {};\n    let handler = {};\n    let {proxy, revoke} = Proxy.revocable(target, handler);\n    //proxy.foo = 12345;\n    //console.log(proxy.foo);\n    target.oof = 123;\n    console.log(target, proxy);\n    revoke();\n    //console.log(proxy.foo);      访问报错\n}\n\n\n/**\n * this指向\n * Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。\n * */\n{\n    let proxy = new Proxy({\n        getThis() {\n            \"use strict\";\n            console.log(this, proxy)\n        }\n    }, {});\n    proxy.getThis();\n}"
        },
        {
            "title": "Reflect",
            "__html": "<h3>Reflect</h3>\n<h5>Proxy是拦截,可以控制是否执行接下来的原生操作.而Reflect相当于原生操作.</h5>\n<ol>\n    <li>Reflect[反映；反射，照出；反省]对象与Proxy对象一样,是为了操作对象提供的API.</li>\n    <li>Reflect对象的方法与Proxy对象的方法一一对应.可以让Proxy对象的方法方便的调取对应的Reflect方法.</li>\n    <li>将Object对象的一些明显属于语言内部的方法[Object.defineProperty等]放到Reflect对象上.</li>\n    <li>让Object操作都编程函数行为.如name in obj delete obj.name 是命令行为.而Reflect.has和Reflect.deleteProperty是函数行为.</li>\n    <li>修改某些Object方法的返回结果使其合理化.</li>\n</ol>\n<h4>静态方法</h4>\n<p>每一个静态方法都对应一个Proxy实例方法.</p>\n<ol>\n    <li><div>属性增/改:</div>Reflect.set(target,name,value,receiver).</li>\n    <li><div>属性删除:</div>Reflect.deleteProperty(target,name).</li>\n    <li><div>属性查:</div>Reflect.get(target,name,receiver).</li>\n    <li><div>in操作符:</div>Reflect.has(target,name).</li>\n    <li><div>遍历:</div>Reflect.ownKeys(target).</li>\n    <li><div>设置属性描述:</div>Reflect.defineProperty(target,name,desc).</li>\n    <li><div>查询属性描述:</div>Reflect.getOwnPropertyDescriptor(target,name).</li>\n    <li><div>设置对象不可拓展:</div>Reflect.preventExtensions(target).</li>\n    <li><div>查询对象不可拓展:</div>Reflect.isExtensible(target).</li>\n    <li><div>设置对象原型:</div>Reflect.setPrototypeOf(target,prototype).</li>\n    <li><div>查询对象原型:</div>Reflect.getPrototypeOf(target).</li>\n    <li><div>作为函数调用,相当于F.p.apply.call(fn,obj,[]):</div>Reflect.apply(target,thisArg,args).</li>\n    <li><div>作为构造函数调用:</div>Reflect.construct(target,args).</li>\n</ol>",
            "code": "/**\n *  Reflect 13\n *\n *  get\n *  set\n *  has\n *  ownKeys\n *\n *  defineProperty\n *  getPropertyDescriptor\n *  deleteProperty\n *\n *  constructor\n *  setPrototypeOf\n *  getPrototypeOf\n *\n *  apply\n *  isExtensible\n *  preventExtensions\n * */\n\n/**\n * set\n * */\n{\n    let o = {\n        set receiver(value) {\n            \"use strict\";\n            this.xxx = value;\n        }\n    };\n    let receiver = {};\n    //  如果name属性设置了赋值函数，则赋值函数的this绑定receiver。那么receiver 的 num 有值,而 o 的 name 没有值\n    Reflect.set(o, 'receiver', '接收器；接受者', receiver);\n    console.log('receiver', receiver);\n    console.log('o', o);\n}\n{\n    let p = {\n        a: 'a'\n    };\n    let handler = {\n        set(target, key, value, receiver) {\n            console.log('set');\n            Reflect.set(target, key, value, receiver);\n            //  如果不传入receiver则无法触发defineProperty\n            //Reflect.set(target, key, value);\n        },\n        defineProperty(target, key, attribute) {\n            console.log('defineProperty', attribute);\n            Reflect.defineProperty(target, key, attribute);\n        }\n    };\n    let obj = new Proxy(p, handler);\n    obj.a = 'A';\n    console.log(obj, p);\n}\n\n/**\n * deleteProperty\n * 返回一个布尔值\n * */\n\n/**\n * constructor\n * 等同于new target(...arguments)\n *\n * */\n{\n    function Greeting(name) {\n        \"use strict\";\n        this.name = name;\n    }\n\n    const instance = Reflect.construct(Greeting, ['张三']);\n    console.log(instance);\n}\n\n/**\n * getPrototypeOf\n * 相当于读取__proto__\n *\n * */\n\n/**\n *setPrototypeOf    target , prototype\n * 返回一个布尔值 , 表示设置成功了没有\n * */\n{\n    const myObj = {name: 'my house is tem'};\n    Reflect.setPrototypeOf(myObj, {\n        getName: function () {\n            return this.name;\n        }\n    });\n    console.log(myObj.getName());\n    const fre = Object.freeze({});\n    var isFail = Reflect.setPrototypeOf(fre, Array.prototype);\n    console.log('isFail是一个布尔值', isFail, fre);\n}\n\n/**\n * apply    func , obj用于绑定this , args\n * 相当于Function.prototype.apply.call (func,obj,args)\n * */\n{\n    const arr = [11, 33, 12, 54, 18, 96];\n    const youngest = Reflect.apply(Math.min, null, arr);\n    console.log('最大值是', youngest);\n    const type = Reflect.apply(Object.prototype.toString, youngest, {});\n    console.log(type);\n}\n\n/**\n * defineProperty   target , prop , descriptor\n * 返回一个布尔值,表示设置property成功了还是失败了\n * */\n{\n    let obj = {};\n    Reflect.defineProperty(obj, 'pierce', {\n        value: 12345,\n    });\n    const p = new Proxy(obj, {\n        defineProperty(target, prop, descriptor) {\n            \"use strict\";\n            return Reflect.defineProperty(target, prop, descriptor);\n        }\n    });\n    p.name = '12345y';\n    console.log(obj, p);\n}\n\n/**\n * getOwnPropertyDescriptor     target , prop\n * 如果target不是对象,则抛出错误\n * */\n\n/**\n * isExtensible     target\n * 如果target不是对象,则抛出错误\n * */\n\n/**\n * preventExtensions    target\n * 如果target不是对象,则抛出错误\n * */\n\n/**\n * ownKeys  target\n * 返回全部自身属性,包括symbol属性和不可枚举属性\n * 如果target不是对象,则抛出错误\n * */\n{\n    const obj = {};\n    Reflect.defineProperty(obj, 'name', {\n        value: 'james',\n    });\n    Reflect.defineProperty(obj, Symbol('啦啦啦'), {\n        value: 'james',\n        enumerable: true,\n    });\n    console.log(obj);\n    console.log('Reflect.ownKeys', Reflect.ownKeys(obj));\n    console.log('Object.getOwnPropertyNames', Object.getOwnPropertyNames(obj));\n    console.log('Object.getOwnPropertySymbols', Object.getOwnPropertySymbols(obj));\n}\n\n\n/**\n * 观察者模式    Observer mode\n * 函数自动观察数据对象,一旦对象有变化,函数自动执行\n *\n *  观察者模式就是在get里面执行观察者\n *  * */\n{\n    const queuedObservers = new Set();\n    const observe = fn => queuedObservers.add(fn);\n    const observable = obj => new Proxy(obj, {\n        set: function (target, key, value, receiver) {\n            const result = Reflect.set(target, key, value, receiver);\n            queuedObservers.forEach(observe => observe());\n            return result;\n        }\n    });\n\n    const obj = observable(queuedObservers);\n    console.log(obj.aa = 1);\n    console.log(queuedObservers);\n}"
        },
        {
            "title": "Promise对象",
            "__html": "<h3>Promise的含义</h3>\n<ol>\n    <li>从语法上将,Promise是一个对象,从它可以获取异步操作的消息.</li>\n    <li>它提供了异步编程的一种解决方案,比传统的回调函数和事件更加合理.</li>\n    <li>Promise是一个容器,里面保存着某个未来才会结束的事件(通常是一个异步事件)的结果.</li>\n</ol>\n<h3>Promise对象的特点</h3>\n<ol>\n    <li>有三种状态:进行中pending,成功fulfilled,失败rejected.</li>\n    <li>对象的状态不受外界影响,任何其他的操作都无法改变这个状态.</li>\n</ol>\n<ol id=\"james\" start=\"3\">\n    <li>一旦改变状态,就不会再变,任何时候都可以得到这个结果.</li>\n    <li>状态的改变有两种可能:1.pending→fulfilled;2.pending→rejected.</li>\n    <li>只要这两种情况发生,状态就凝固了,不会再变,称为已定型[resolved].</li>\n    <li>已定型的Promise对象添加回调函数,也会得到结果,但这个结果是死的.因为每次都会生成一个新的Promise实例.</li>\n</ol>\n<h3>作用</h3>\n<ol>\n    <li>可以将异步操作以同步形式表示出来,防止层层回调.</li>\n    <li>Promise提供统一的接口,使控制异步操作更容易.</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n    <li>无法取消Promise.</li>\n    <li>必须指明回调,否则会抛出错误,不会反映到外部.</li>\n    <li>pending状态下,无法得知目前进展</li>\n</ol>\n<hr>\n<h3>Promise.prototype.then</h3>\n<ol>\n    <li>为Promise实例添加状态改变时的回调函数.</li>\n    <li>返回一个新的Promise实例,不是原来那个Promise实例.因此可以then后面再then.</li>\n    <li>而then里面的return值是一下一个函数的实参.</li>\n</ol>\n<h3>Promise.prototype.catch</h3>\n<ol>\n    <li>是.then(null/undefined , reject)的别名,指定发生错误时的回调函数.</li>\n    <li>如果then方法指定的回调函数在运行中发送错误,也会被catch方法捕获.这是因为Promise对象的错误具有冒泡性质,会之一向后传递.</li>\n</ol>\n<h3>Promise.prototype.finally</h3>\n<ol>\n    <li>用于无论Promise对象状态如何,都会执行的操作.</li>\n    <li>finally方法的回到函数不接受任何参数,所以无法判断Promise对象的状态是fulfilled还是rejected.所以finally里的操作应该与状态无关,不依赖Promise对象的执行结果.</li>\n</ol>\n<hr>\n<h3>Promise.all</h3>\n<ol>\n    <li>Promise.all用于将多个Promise实例包装成一个新的Promise实例.</li>\n    <li>它接收一个具有Iterator接口的参数作为实参,每个成员都必须是Promise实例,如果不是,则调用<span class=\"red\">Promise.resolve</span>方法将它转为Promise的实例.</li>\n    <li>当所有参数的成员的状态都是fulfilled时,它的状态才会变成fulfilled.</li>\n    <li>只要有一个成员的状态是rejected,它的状态就变成rejected.此时第一个被rejected的实例返回值,会传递给它的catch回调.</li>\n    <li>如果某个成员定义了catch方法,并且它的状态变成了rejected,则不会触发Promise.all的catch方法.</li>\n    <li>因为这个执行了自身catch的成员返回了一个新的Promise对象,状态为fulfilled,而Promise.all的参数指向了新的对象.所以all执行了then方法.</li>\n    <li>它的then方法的参数总是所有实例的返回值.</li>\n</ol>\n<h3>Promise.race</h3>\n<ol>\n    <li>Promise.race将多个Promise实例,包装成一个新的Promise实例.</li>\n    <li>它接收和all相同的参数,如果有某个成员的状态发生改变,则它会发生改变,改变的成员实例的返回值传递给它的回调函数.</li>\n</ol>\n<h3>Promise.resolve</h3>\n<p>将现有对象转为Promise对象.</p>\n<ol>\n    <li>参数是一个Promise实例,那么return这个实例.</li>\n    <li>参数是一个具有then方法的对象,则返回一个执行了这个then方法的实例.</li>\n    <li>参数是不具有then方法,或不是一个对象,则返回一个状态为fulfilled的实例.</li>\n    <li>无参数,返回一个状态为fulfilled的实例.</li>\n</ol>\n<h3>Promise.reject</h3>\n<ol>\n    <li>返回一个实例,状态为rejected,值为传入的参数.</li>\n</ol>\n<h3>Promise.try</h3>\n<p>只是个提案,不知道或不想区分,函数f是同步还是异步.有两种方法可以实现.</p>\n<ol>\n    <li>async函数</li>\n    <li>new Promise(resolve=>resolve(f()))</li>\n</ol>",
            "code": "{\n    const timeout = new Promise((resolve, reject) => {\n        if (Math.random() > 0.5) {\n            resolve('√√√');\n        } else {\n            reject('xxx')\n        }\n    });\n    timeout.then(value => console.log(value), err => console.log(err));\n}\n\n{\n    const getJSON = function (url) {\n        return new Promise(function (resolve, reject) {\n            const handler = function () {\n                if (this.readyState !== 4) {\n                    return;\n                }\n                if (this.status === 200) {\n                    resolve(this.response);\n                } else {\n                    reject(this.statusText);\n                }\n            };\n            const client = new XMLHttpRequest();\n            client.open(\"GET\", url);\n            client.onreadystatechange = handler;\n            client.responseType = \"json\";\n            client.setRequestHeader(\"Accept\", \"application/json\");\n            client.send();\n        });\n    };\n    getJSON(\"./15.Promise对象.html\").then(function (json, promise) {\n        console.log('Contents: ' + json);\n        console.log(promise)\n    }, function (error) {\n        console.error('出错了', error);\n    });\n}\n\n{\n    const p1 = new Promise(function (resolve, reject) {\n        // ...\n    });\n    const p2 = new Promise(function (resolve, reject) {\n        // ...\n        resolve(p1);\n    });\n    p2.then(val => console.log(val));\n\n    /**\n     * 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态.\n     * 如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变.\n     * 如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行.\n     * */\n}\n\n{\n    const p1 = new Promise(function (resolve, reject) {\n\n    });\n    const p2 = new Promise(function (resolve, reject) {\n        resolve(p1);\n        console.log('p2')\n\n    });\n    p2.then(result => console.log(result))\n        .catch(error => console.log(error));\n}\n\n{\n    new Promise(function (resolve, reject) {\n    }).then(val => console.log(val));\n    //  resolved是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。\n\n    //  一般来说,调用完resolve或reject之后,Promise的使命就完成了,后续操作应该放在then里.\n    new Promise(function (resolve) {\n        resolve(111);\n    })\n}\n\n/**\n * Promise.prototype.then\n * */\n{\n    new Promise(function (resolve) {\n        resolve(1);\n    }).then(function (resolve) {\n        console.log(resolve);\n        return 2;\n    }).then(function (resolve) {\n        console.log(resolve)\n    })\n}\n\n/**\n * Promise.prototype.catch\n * */\n{\n    function getJSON(url) {\n        return new Promise(function (resolve, reject) {\n            reject(url);\n        })\n    }\n\n    getJSON('/posts.json').then(function (posts) {\n        // ...\n    }).catch(function (error) {\n        // 处理 getJSON 和 前一个回调函数运行时发生的错误\n        console.log('发生错误！', error);\n    });\n}\n\n{\n    new Promise(function (resolve, reject) {\n        //  普通地抛出错误,没问题\n        throw new Error('xxx');\n\n    }).catch(function (err) {\n        console.log(err);\n    });\n    new Promise(function (resolve, reject) {\n        resolve('ok');\n        //  但如果resolve指向了,promise会认为他的状态变成了成功,这时会冻结这个状态.\n        //  抛出错误是不会触发catch的,只不过这个例子模拟不出来,用reject可以模拟出\n        //throw new Error('xxx');\n        reject('false');\n\n    }).then(function (value) {\n        console.log(value)\n    }).catch(function (error) {\n        console.log(error)\n    });\n}\n\n{\n    new Promise(function (resolve, reject) {\n        // 下面一行会报错，因为x没有声明\n        throw new Error('xxx');\n    });\n    console.log('xxx报错不会影响外层代码');\n}\n\n/**\n * Promise.all\n * 用于将多个Promise实例包装成一个新的Promise实例\n * */\n{\n    setTimeout(function () {\n        console.clear();\n        return;\n        const p1 = new Promise(function (resolve, reject) {\n            \"use strict\";\n            setTimeout(function () {\n                reject('errrrrrrrrrr');\n            }, 1);\n        }).catch(function (err) {\n            console.log('p1自己的catch', err);\n            return err;\n        });\n        const p2 = new Promise(function (resolve, reject) {\n            resolve('p2');\n        });\n        const p3 = new Promise(function (resolve, reject) {\n            resolve('p3');\n        });\n        const p = Promise.all([p1, p2, p3]).then(function (res) {\n            alert('red')\n        }).catch(function (err) {\n            console.log('all的catch\\n', err);\n            return 123\n        }).finally(function () {\n            console.log('**********Promise.all  finally***************');\n            console.log(p, p1, p2, p3);\n            setTimeout(function () {\n                console.log(p);\n            }, 2)\n        });\n    }, 100);\n}\n\n/**\n * Promise.race\n * 如果说.all是等待全部实例完成,那么race就是等待第一个实例完成\n * */\n{\n    setTimeout(function () {\n        console.clear();\n        return;\n        const p1 = new Promise(function (resolve, reject) {\n\n        });\n        const p2 = new Promise(function (resolve, reject) {\n            resolve('p2成功了');\n        }).then(function (result) {\n            var str = 'p2的then:' + result;\n            console.log(str);\n            return str;\n        });\n        const p = Promise.race(new Set([p1, p2]));\n        p.then(function (result) {\n            console.log(result);\n        }).finally(function () {\n            setTimeout(function () {\n                console.log(p);\n                console.log(p1, p2);\n            }, 1)\n        })\n    }, 100);\n}\n\n\n/**\n *  Promise.resolve\n *  返回一个Promise实例\n * */\n{\n    setTimeout(function () {\n        console.clear();\n        return;\n        let obj = {\n            then: function (resolve, reject) {\n                reject(1);\n            }\n        };\n        const p = Promise.resolve(obj).catch(function (err) {\n            console.log(err);\n            return err;\n        });\n        setTimeout(function () {\n            console.log(p);\n        }, 11)\n    }, 100)\n}\n\n\n/**\n *  Promise.reject\n *  返回一个状态为reject的实例,值为Promise.reject方法的参数\n * */\n\n\n/**\n * 应用 加载图片\n * */\n{\n    setTimeout(function () {\n        console.clear();\n        const preLoadImage = function (path) {\n            return new Promise(function (resolve, reject) {\n                const image = new Image();\n                image.onload = resolve;\n                image.onerror = reject;\n                image.src = path;\n            })\n        };\n        preLoadImage('ht1tps://www.baidu.com/img/bd_logo1.png?where=super').then(function (resolve) {\n            console.log(this, resolve);\n        }).catch(function (err) {\n            console.log(err);\n        });\n    }, 100);\n}\n\n/**\n * 发送10个ajax,链式调用,同步发送三个\n * */\n{\n    setTimeout(function () {\n        return;\n        console.clear();\n        var i = 0;\n\n        function createPromise(param) {\n            //console.log(param);\n            i++;\n            //console.log(`执行 的是${i}`);\n            return new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                    if (i >= 10) {\n                        reject();\n                        return;\n                    }\n                    resolve(_i);\n                }, Math.random() * 1000);\n                var _i = i;\n            }).then(function (x) {\n                console.log(`执行完了${x}`);\n                createPromise(param);\n            }).catch(function () {\n            });\n        }\n\n        createPromise('a');\n        createPromise('b');\n        createPromise('c');\n\n    }, 333);\n\n}"
        },
        {
            "title": "Iterator 和 for...of 循环",
            "__html": "<h3>Iterator（遍历器）</h3>\n<ol>\n    <li>es6有四种数据集合,数据,对象,map,set.遍历器定义了统一的接口机制来处理不同的数据.</li>\n    <li>遍历器是一种机制,提供了一种接口,提供统一的访问机制,可以依次处理这四种数据结构的成员.</li>\n</ol>\n<h4>作用:</h4>\n<ol>\n    <li>提供访问接口.</li>\n    <li>使成员按次序排列.</li>\n    <li>提供for...of消费.</li>\n</ol>\n<h4>遍历过程</h4>\n<ol>\n    <li>创建一个指针对象,指向当前数据结构的起始位置.</li>\n    <li>第一次调用指针的next方法,可以将指针指向数据结构的第一个成员.</li>\n    <li>不断调用指针对象的next方法直到它指向数据结构的结束位置.</li>\n    <li>每一次调用next方法,都会返回数据结构中的当前成员信息.就是返回一个包含value和done两个属性的对象.value是成员的值,done是遍历是否完成.</li>\n    <li class=\"red\">Iterator只是把接口规格加到数据结构上,遍历器与它所遍历的数据结构是分开的.</li>\n</ol>\n<h4>默认Iterator接口</h4>\n<ol>\n    <li>接口的目的就是为所有数据结构提供统一的访问机制,即for...of循环.</li>\n    <li>当使用for...of循环遍历某种数据结构时,该循环会自动去寻找Iterator接口.</li>\n    <li>默认Iterator接口部署在数据结构的Symbol.Iterator属性.凡是部署了Symbol.iterator属性的数据结构,就称为部署了遍历器接口.调用这个接口,就会返回一个遍历器对象.</li>\n    <li>数据结构的Symbol.iterator属性指向遍历器生成函数.调用这个函数会返回一个遍历器.</li>\n</ol>\n<h4>原生具备Iterator接口的数据结构</h4>\n<ol>\n    <li>Array</li>\n    <li>Map</li>\n    <li>Set</li>\n    <li>String</li>\n    <li>TypedArray</li>\n    <li>NodeList对象</li>\n    <li>arguments对象</li>\n</ol>\n<p>对象上没有Iterator接口,是因为对象的属性遍历规则不确定,需要手动指定.</p>\n<p>本质上,遍历器是一种线性处理,对于任何非线性的数据机构部署遍历器接口,就等于部署一种线性转换.</p>\n<h4>对于类数组对象</h4>\n<ol>\n    <li>可以使其转为数组,再调用数组的Symbol.iterator返回遍历器.</li>\n    <li>可以使其原型对象的Symbol.iterator方法指向数组原型对象的Symbol.iterator方法.</li>\n</ol>\n<p class=\"red\">如果Symbol.iterator方法对应的不是遍历器生成函数,在进行相关操作时,则会抛出错误.</p>\n<h3>Iterator接口的场合</h3>\n<ol>\n    <li>for...of,Array.from,Map,Set,WeaKSet,WeakMap,Promise.all,Promise.race.</li>\n    <li>解构赋值,set结构进行解构赋值时,会默认调用Symbol.iterator方法.</li>\n    <li>扩展运算符.</li>\n    <li>yield*,后面跟的是一个可遍历的结构,它会调用该结构的遍历器接口.</li>\n</ol>\n<h4>字符串的Iterator接口</h4>\n<ol>\n    <li>字符串是一个类似数据的对象,也具有其原生Iterator接口.</li>\n    <li>只有new出来的基本对象类型的字符串,才可以修改器Symbol.iterator方法.</li>\n    <li>对于字符串来说,for...of循环还有一个特点,就是会正确识别 32 位 UTF-16 字符。</li>\n</ol>\n<h4 style=\"color:red;\">Iterator与Generator</h4>\n<h4>遍历对象的return,throw</h4>\n<ol>\n    <li>遍历器除了next,还有return和throw方法.它们是可选的.</li>\n    <li>如果for...of循环提前退出,报错,或有break语句时触发return方法.</li>\n    <li>return方法必须返回一个对象,这是 Generator 规格决定的.</li>\n    <li>throw方法主要是配合 Generator 函数使用,一般的遍历器对象用不到这个方法.</li>\n</ol>\n<h4>for...of循环</h4>\n<ol>\n    <li>对数组,只返回具有数字索引的属性.</li>\n    <li>对map和set,遍历的顺序是按照各个成员被添加进数据结构的顺序.</li>\n    <li>对map遍历,返回一个数组,数组的两个成员是被遍历成员的键和值.对set遍历,返回一个值.</li>\n    <li>对entries,keys,values方法生成的对象,遍历的都是计算生成的数据结构.</li>\n    <li>对对象,可以调用Reflect.ownKeys返回一个对象的键名的数组.</li>\n    <li>另一个办法是用Generator重新包装一下.</li>\n</ol>",
            "code": "/**\n * 模拟next方法\n * */\n{\n    function makeIterator(arr) {\n        \"use strict\";\n        let nextIndex = 0;\n        return {\n            //next: function () {\n            //    return nextIndex < arr.length ? {value: arr[nextIndex++], done: false} : {value: undefined, done: true};\n            //},\n            next: function () {\n                return nextIndex < arr.length ? {value: arr[nextIndex++]} : {done: true};\n            }\n        }\n    }\n\n    let it = makeIterator(['a', 'b']);\n    let a = it.next();\n    let b = it.next();\n    let c = it.next();\n    //console.log(a, b, c, it);\n}\n\n/**\n *  array的原生遍历器\n * */\n{\n    let arr = ['a', 'b', 'c'];\n    let iter = arr[Symbol.iterator]();\n    //console.log(iter);\n    //console.log(iter.next());\n    //console.log(iter.next());\n    //console.log(iter.next());\n    //console.log(iter.next());\n}\n\n/**\n * 给对象部署Iterator接口\n * */\n{\n    class RangeIterator {\n        constructor(start, stop) {\n            this.value = start;\n            this.stop = stop;\n        }\n\n        [Symbol.iterator]() {\n            return this;\n        }\n\n        next() {\n            var value = this.value;\n            if (value < this.stop) {\n                this.value++;\n                return {done: false, value: value};\n            }\n            return {done: true, value: undefined};\n        }\n    }\n\n    function range(start, stop) {\n        \"use strict\";\n        return new RangeIterator(start, stop);\n    }\n\n    let obj = range(0, 3);\n    for (var value of obj) {\n        //console.log(value);\n    }\n}\n/**\n * 通过遍历器实现指针结构的例子。\n * */\n{\n    function Obj(value) {\n        this.value = value;\n        this.next = null;\n    }\n\n    Obj.prototype[Symbol.iterator] = function () {\n        var iterator = {next: next};\n        var current = this;\n\n        function next() {\n            if (current) {\n                var value = current.value;\n                current = current.next;\n                return {done: false, value: value};\n            } else {\n                return {done: true};\n            }\n        }\n\n        return iterator;\n    };\n\n    var one = new Obj(1);\n    var two = new Obj(2);\n    var three = new Obj(3);\n    one.next = two;\n    two.next = three;\n    for (var i of one) {\n        //console.log(i); // 1, 2, 3\n    }\n}\n//  我的\n{\n    let obj = {count: 3};\n    obj[Symbol.iterator] = function () {\n        let _this = this;\n        return {\n            next() {\n                if (_this.count--) {\n                    return {value: 'james'}\n                } else {\n                    return {done: true}\n                }\n            }\n        }\n    };\n    for (let value of obj) {\n        //console.log(value)\n    }\n}\n\n/**\n * 对于类数组对象\n * */\n{\n    {\n        let li = [...document.querySelectorAll('li')];\n        var liIt = li[Symbol.iterator]();\n        //console.log(liIt.next());\n    }\n    {\n        NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n        let li = document.querySelectorAll('li');\n        let liIt = li[Symbol.iterator]();\n        //console.log(liIt.next());\n    }\n}\n\n/**\n * 字符串的Iterator接口\n * */\n{\n    let str = new String(\"james\");\n    let strIterator = str[Symbol.iterator]();\n    //console.log(strIterator.next());\n    str[Symbol.iterator] = function () {\n        return {\n            isThird: false,\n            index: 0,\n            next() {\n                this.index++;\n                if (this.index === 3) {\n                    this.isThird = true;\n                }\n                if (this.isThird) {\n                    return {done: true};\n                }\n                return {value: '?'};\n            }\n        }\n    };\n    let newStrIterator = str[Symbol.iterator]();\n    //console.log(newStrIterator.next());\n    console.log([...str]);\n\n    //  对于字符串来说，for...of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。\n    for (let x of '\\uD83D\\uDC0A\\uD83D\\uDC0B\\uD83D\\uDC0C\\uD83D\\uDC0D\\uD83D\\uDC0E\\uD83D\\uDC0F') {\n        //console.log(x);\n    }\n\n}\n\n\n/**\n *  return 和 throw\n * */\n{\n    function readLinesSync(file) {\n        return {\n            [Symbol.iterator]() {\n                return {\n                    next() {\n                        return {done: false};\n                    },\n                    return() {\n                        file.close();\n                        return {done: true};\n                    }\n                };\n            }\n        };\n    }\n\n    let obj = readLinesSync({\n        close: function () {\n            console.log('调用结束了');\n        }\n    });\n    james:\n        for (let line of obj) {\n            break james;\n        }\n}\n\n/**\n * for...of\n * */\n{\n    //  证明array已经部署了Symbol.iterator\n    const arr = ['red', 'green', 'blue'];\n    const obj = {};\n    obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n    for (let v of obj) {\n        //console.log(v); // red green blue\n    }\n}\n\n{\n    //  set\n    const setObj = new Set(['xx', 'yy']);\n    setObj.add('james');\n    for (let key of setObj) {\n        //console.log(key);\n    }\n    //  map\n    const mapObj = new Map();\n    mapObj.set('?', 'xx');\n    mapObj.set({}, 'yy');\n    for (let key of mapObj) {\n        //console.log(key);\n    }\n}\n\n{\n    //  计算生成的数据结构\n    let arr = [1, 2, 33];\n    //console.log(arr.entries());\n    for (let pair of arr.entries()) {\n        //console.log(pair);\n    }\n}\n\n{\n    //  类数组对象\n    function printArgs() {\n        for (let x of arguments) {\n            //console.log(x);\n        }\n    }\n\n    printArgs('a', 'b');\n}\n\n{\n    //  对象,使用Reflect.ownKeys\n    for (let key of Reflect.ownKeys({'xx': 1})) {\n        //console.log(key);\n    }\n}"
        },
        {
            "title": "Generator 函数的语法",
            "__html": "<h3>Generator</h3>\n<ol>\n    <li>Generator提供了一种异步编程的解决方案,分装了多个内部状态.</li>\n    <li>执行Generator会返回一个遍历器对象.</li>\n    <li>形式上Generator是一个普通函数,function关键字与函数间有个*号,函数体内部使用yield表达式,(yield)产出不同的状态.</li>\n</ol>\n<h4>执行</h4>\n<ol>\n    <li>调用 Generator 函数后,该函数并不执行,返回的也不是函数运行结果,而是一个指向内部状态的指针对象,遍历器对象.</li>\n    <li>下一步必须调用遍历器对象的next方法,使得指针指向下一个状态.</li>\n    <li>每次调用next方法,内部指针就从函数头部或上一次停下来的地方开始执行,直到遇到下一个yield表达式或return语句.</li>\n    <li>yield表达式是暂停执行的标记,next方法是恢复执行的方法.</li>\n</ol>\n<hr>\n<h4>yield表达式</h4>\n<ol>\n    <li>遇到yield表达式,就暂停执行后面的操作,并将跟在yield后面的那个表达式的值作为返回对象的value值.</li>\n    <li>只有调用next方法,内部指针指向该语句才会执行,这是手动的惰性求值语法.</li>\n    <li>由于通过yield返回了一系列的值,这个函数才被叫做生成器.</li>\n</ol>\n<h5>用法</h5>\n<ol>\n    <li>yield只能在Generator函数中使用.</li>\n    <li>如果要在另一个表达式中使用,则必须放在小括号中.</li>\n    <li>yield表达式用作函数参数或放在赋值表达式的右边,可以不加括号.</li>\n</ol>\n<h5>与Iterator接口的关系</h5>\n<ol>\n    <li>由于Generator是遍历器生成函数,因此可以把Generator赋值给对象的Symbol.iterator属性,从而使得该对象具有Iterator接口.</li>\n    <li>Generator函数执行返回的 遍历器对象的 Symbol.iterator属性执行后返回这个遍历器对象.</li>\n</ol>\n<h4>next方法的参数</h4>\n<ol>\n    <li>yield表达式本身没有返回值,next方法可以带一个参数,改参数就会当做上一个yield表达式的返回值.</li>\n    <li>这个功能有很重要的语法意义,Generator函数从暂停状态恢复到运行,它的上下文状态是不变的.</li>\n    <li>通过next方法的参数,就有办法在Generator函数开始运行之后,继续向函数体内部注入值.</li>\n    <li>也就是说,在Generator函数运行的不同阶段,从外部向内部注入不同的值,从而调整函数行为.</li>\n    <li>第一次使用next方法时,传递参数是无效的.因为第一个next方法用来启动遍历器对象.</li>\n</ol>\n<h4>for...of循环</h4>\n<ol>\n    <li>for...of可以自动遍历generator生成的iterator对象,不必调用next方法.</li>\n    <li class=\"red\">一旦next方法返回的对象的done属性为true,则循环终止,且不包含该返回对象.所以说,遍历不到return 的值.</li>\n    <li>扩展运算符...\\结构赋值\\Array.from方法内部调用的都是遍历器接口.它们都可以将Generator函数返回的Iterator对象作为被遍历的值.</li>\n</ol>\n<h4>Generator.prototype.throw</h4>\n<ol>\n    <li>Generator函数返回的遍历器对象都有一个throw方法,可以在函数体外抛出错误,然后在Generator函数体内捕获.</li>\n    <li>Generator函数内部的catch捕获过外部实例的throw方法抛出的错误之后,就不会再捕获后面的错误了.</li>\n    <li>throw方法可以传递一个参数,被Generator内部的catch语句接收.</li>\n    <li>全局throw方法仅能被throw语句捕获,Generator实例的throw不仅如此,还可以被Generator函数内部的catch捕获</li>\n    <li class=\"red\">在抛出错误之前,必须先执行过next方法,才能被Generator内部catch捕获.因为next相当于告诉实例启动这个遍历器.</li>\n    <li>throw方法在被Generator内部捕获之后,会继续执行到下一条yield表达式.</li>\n    <li>throw方法没有被Generator捕获,就不会继续执行了,此后调用的next方法返回{value:undefined,done:true}.</li>\n</ol>\n<h4>Generator.prototype.return</h4>\n<ol>\n    <li>用于结束Generator函数.</li>\n    <li>return后调用next方法,返回的value是undefined,done是true.return方法返回的结果相同.</li>\n    <li>如果Generator函数内部有try...finally语句,且上一次next暂停在try块,则return方法推迟到finally块执行完之后.在这期间依然可以调用next方法.</li>\n</ol>\n<hr>\n<h4>next,throw,return的共同点</h4>\n<ol>\n    <li>三个方法的本质是同一件事,都是让Generator函数恢复执行,并使用不同的语句替换yield表达式.</li>\n    <li>next方法是通过参数,将上一个yield表达式替换成一个值.</li>\n    <li>throw将yield表达式替换成一个throw语句.</li>\n    <li>return将yield表达式替换成一个return语句.</li>\n</ol>\n<hr>\n<h4>yield*表达式</h4>\n<ol>\n    <li>如果在Generator函数内部调用另一个Generator函数,默认情况下:</li>\n    <li>普通函数式调用没反应,因为不在yield表达式后面.</li>\n    <li>普通yield表达式后面跟一个Generator函数,会返回这个Generator的iterator.</li>\n    <li>yield*表达式用来在一个Generator函数里面执行另一个Generator函数.</li>\n    <li>yield*表达式后必须是一个具有iterator接口的对象.</li>\n    <li>yield*表达式后面的Generator函数,如果没有return,则相当于一个for...of遍历了这个对象.如果有return,需要let\n        _temp保存yield表达式的值,这个_temp的值就是Generator函数的return值.\n    </li>\n    <li>yield*本身不会暂停,后面的Generator对象里的yield才会暂停.</li>\n</ol>\n<h4>作为对象属性的Generator函数</h4>\n<ol>\n    <li>如果一个对象的属性是Generator函数,则可以{*foo(){},}.</li>\n</ol>\n<h4>Generator与状态机</h4>\n<ol>\n    <li>状态机是两相或多项转换的机制,如jquery的toggle.</li>\n</ol>\n<h4>Generator与协程</h4>\n<ol>\n    <li>协程是一种程序运行的方式,可以理解成'协作的线程'或'协作的函数'.</li>\n    <li>多个函数可以并行执行,但只有一个线程处于正在运行的状态,其他线程都是暂停态.</li>\n    <li>也就是说,一个线程或函数,可以执行到一半,暂停,将执行权交给另一线程或函数.</li>\n    <li class=\"red\">这种可以并行执行,交换执行权的线程,叫做协程.</li>\n</ol>\n<ol start=\"5\">\n    <li>javascript语言只能保持一个调用栈,但协程可以同时保持自己的调用栈.</li>\n    <li>在抛出错误的时候,可以找到原始的调用栈,而原始调用栈不受影响.</li>\n    <li>Generator是半协程实现,只有Generator函数的调用者,才能将程序的执行权还给Generator函数.</li>\n</ol>\n<h4>Generator与当前执行环境context</h4>\n<ol>\n    <li>js运行时,会产生一个context,包含了当前所有的变量和对象.</li>\n    <li>Generator函数执行产生的context,一旦遇到yield命令,就会暂时退出环境栈,但并不消失,里面的所有变量和对象会冻结在当前状态.</li>\n    <li>再次执行next命令时,这个context又会重新加入调用栈,冻结的变量和对象会恢复.</li>\n</ol>",
            "code": "{\n    function* hello() {\n        \"use strict\";\n        yield 'hello';\n        yield (function () {\n            alert('惰性求值,暂时不执行');\n            return 'word';\n        }());\n        console.log('允许执行了end');\n        return 'ending';\n    }\n\n    let h = hello();\n    //console.log(h);\n    //console.log(h.next());\n    //console.log(h.next());\n    //console.log(h.next());\n}\n\n{\n    var arr = [1, [[2, 3], 4], [5, 6]];\n    var flat = function* (a) {\n        var length = a.length;\n        for (var i = 0; i < length; i++) {\n            var item = a[i];\n            if (typeof item !== 'number') {\n                yield* flat(item);\n            } else {\n                //console.log('Hello' + (yield item)); // OK\n                yield item;\n            }\n        }\n    };\n\n    let fl = flat(arr);\n    fl.next();\n    for (var f of fl) {\n        //console.log(f);\n    }\n}\n\n{\n    var myIterable = {};\n    myIterable[Symbol.iterator] = function* () {\n        yield 1;\n        yield 12;\n        yield 3;\n    };\n\n    //console.log([...myIterable]);\n    let gen = myIterable[Symbol.iterator]();\n    //console.log(gen.next());\n}\n\n{\n    function* gen() {\n\n    }\n\n    var g = gen();\n    //  Generator函数指向返回的遍历器对象的Symbol.iterator属性执行后返回的对象===这个遍历器对象\n    //console.log(g, g[Symbol.iterator]() === g);\n}\n\n/**\n * next方法,可以向函数内传递参数,作为上一次执行yield表达式的值\n * */\n{\n    function* f() {\n        \"use strict\";\n        for (var i = 0; true; i++) {\n            var reset = yield i;\n            if (reset) {\n                i = -11;\n            }\n        }\n    }\n\n    let g = f();\n    //console.log(g.next());\n    //console.log(g.next());\n    //console.log(g.next());\n    //console.log(g.next(1));\n    //console.log(g.next());\n}\n\n{\n    function* foo(x) {\n        \"use strict\";\n        let y = 2 * (yield (x + 1));\n        let z = yield(y / 3);\n        return x + y + z;\n    }\n\n    let a = foo(3);\n    a.next();\n    a.next(3);\n    //console.log(a.next(2));\n}\n\n{\n    function* dataConsumer() {\n        \"use strict\";\n        //console.log('Started');\n        console.log(`1.${yield}`);\n        console.log(`2.${yield}`);\n        return 'result';\n    }\n\n    let genObj = dataConsumer();\n    genObj.next();\n    //console.log(genObj.next('a'));\n    //console.log(genObj.next('b'));\n}\n\n\n/**\n *  由于第一个next的参数会被忽略,所以只要在传参之前预调用一个next就行了\n * */\n{\n    function wrapper(generatorFunction) {\n        return function (...args) {\n            let generatorObject = generatorFunction(...args);\n            generatorObject.next();\n            return generatorObject;\n        };\n    }\n\n    const wrapped = wrapper(function* () {\n        console.log(`First input: ${yield}`);\n        console.log(`Second input: ${yield}`);\n        return 'DONE';\n    });\n\n    let wr = wrapped();\n    //console.log(wr.next('hello!'));\n    //console.log(wr.next('hello!'));\n\n\n    //  我的\n    function gen(x) {\n        let obj = (function* () {\n            console.log(`第${yield '??'}[1]是:${x}`);\n            console.log(`第${yield 'ffff'}[2]是:${x}`);\n        }());\n        obj.next();\n        return obj;\n    }\n\n    let b = gen('james');\n    //console.log(b.next(1));\n    //console.log(b.next(2))\n}\n\n/**\n * for...of\n * */\n{\n    let gen = function* () {\n        yield 1;\n        yield 2;\n        return 3;\n    };\n    let obj = gen();\n    for (let key of obj) {\n        //console.log(key);\n    }\n    //console.log(obj.next());\n}\n/**\n * for...of generator 的 斐波那契\n * */\n{\n    function* fib(x) {\n        let [p, n] = [1, 0];\n        while (x) {\n            [p, n] = [n, n + p];\n            yield n;\n            x--;\n        }\n        return false;\n    }\n\n    let fi = fib(20);\n    for (let key of fi) {\n        //console.log(key);\n    }\n\n}\n\n/**\n * for...of 循环对象\n * */\n{\n    function* gen(x) {\n        \"use strict\";\n        let propKeys = Reflect.ownKeys(x);\n        for (let key of propKeys) {\n            yield {'key': key, 'value': x[key]};\n        }\n    }\n\n    let obj = {name: 'james', [Symbol('ncaa')]: '??'};\n    let g = gen(obj);\n    for (let key of g) {\n        //console.log(key);\n    }\n}\n\n{\n    //  将Generator部署到Symbol.iterator属性上\n    function* objectEntries() {\n        \"use strict\";\n        let propKeys = Object.keys(this);\n        for (let propKey of propKeys) {\n            yield [propKey, this[propKey]]\n        }\n    }\n\n    let jane = {first: 'jane', last: 'james'};\n    jane[Symbol.iterator] = objectEntries;\n\n    for (let [key, value] of jane) {\n        //console.log(key, value);\n    }\n\n}\n\n/**\n *  扩展运算符\\解构赋值\\Array.from\n * */\n{\n    //  解构\n    let [x, y, z, w] = num();\n\n    //console.log(x, y, z, w);\n\n    function* num() {\n        \"use strict\";\n        yield 1;\n        yield 2;\n        yield 3;\n        return 4;\n    }\n\n    //  扩展运算符\n    //console.log([...num()]);\n    //  Array.from\n    //console.log(Array.from(num()));\n\n    //  对象的Symbol.iterator\n    let obj = {};\n    obj[Symbol.iterator] = num;\n    for (let key of obj) {\n        //console.log(key)\n    }\n}\n\n\n/**\n * Generator.prototype.throw\n * */\n{\n    function* g() {\n        \"use strict\";\n        try {\n            yield 1;\n            yield 1;\n            yield 1;\n        } catch (err) {\n            console.log(`内部捕获${err}`, `\\n由于 Generator 函数内部的catch语句已经执行过了，再次抛出错误不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。`);\n        }\n        yield 2;\n        yield 3;\n    }\n\n    let i = g();\n    //  执行next是必要的\n    i.next();\n    try {\n        //console.log(i.throw('a'));\n        //console.log(i.throw('b'));\n    } catch (err) {\n        console.log(`外部捕获${err}`)\n    }\n    //console.log(i.next())\n}\n\n/**\n *  Generator.prototype.return\n * */\n{\n    function* num() {\n        \"use strict\";\n        yield 1;\n        //  如果上一次暂停在try块里,则等到finally块里的代码执行完才真正return\n        try {\n            yield 2;\n            yield 3;\n        } finally {\n            yield 4;\n            yield 5;\n        }\n        yield 6;\n    }\n\n    let g = num();\n    g.next();\n    g.next();\n    //console.log(g.return());\n    //console.log(g.next());\n}\n\n//  *********\n/**\n * yield *\n * */\n{\n    function* foo() {\n        yield 'a';\n        yield 'b';\n    }\n\n    function* bar() {\n        yield 'x';\n        yield* foo();\n        yield 'y';\n    }\n\n    // *********************等同于\n    {\n        function* bar() {\n            yield 'x';\n            yield 'a';\n            yield 'b';\n            yield 'y';\n        }\n    }\n\n    // ***********************等同于\n    {\n        function* bar() {\n            yield 'x';\n            for (let v of foo()) {\n                yield v;\n            }\n            yield 'y';\n        }\n    }\n\n    for (let v of bar()) {\n        //console.log(v);\n    }\n}\n{\n    function* inner() {\n        yield 2;\n    }\n\n    function* outer1() {\n        yield 1;\n        yield inner();\n        yield 3;\n    }\n\n    var gen = outer1();\n    //console.log(gen.next().value);\n    //console.log(gen.next().value.next().value);  // 返回一个遍历器对象\n    //console.log(gen.next().value);\n\n    //  相当于\n    function* outer2() {\n        yield 1;\n        yield* inner();\n        yield 3;\n    }\n\n    var gen = outer2();\n    //console.log(gen.next().value);\n    //console.log(gen.next().value);\n    //console.log(gen.next().value);\n}\n{\n    let a = (function* () {\n        yield 2;\n        yield 3;\n    }());\n    let delegatingIterator = (function* () {\n        yield 1;\n        yield* a;\n        yield 4;\n    }());\n\n    for (let value of delegatingIterator) {\n        //console.log(value);\n    }\n}\n//  在内部调用的Generator函数有return语句时\n{\n    let a = (function* () {\n        yield 2;\n        yield 3;\n        return 4;\n    }());\n    let b = (function* () {\n        yield 1;\n        let _temp = (yield* a);\n        yield _temp;\n        yield 5;\n        return 6;\n    }());\n    for (let key of b) {\n        //console.log(key);\n    }\n}\n\n{\n    function* foo() {\n        \"use strict\";\n        yield 1;\n        return 2\n    }\n\n    function* bar() {\n        \"use strict\";\n        let f = yield* foo();\n        yield f;\n        yield 3;\n    }\n\n    let gen = bar();\n    for (let key of gen) {\n        //console.log(key);\n    }\n}\n\n{\n    function* genFuncWithReturn() {\n        yield 'a';\n        yield 'b';\n        return 'The result';\n    }\n\n    function* logReturned(genObj) {\n        let result = yield* genObj;\n        console.log(result);\n    }\n\n    //let a = [...logReturned(genFuncWithReturn())];\n}\n\n//  数组的深度遍历\n{\n    function* getArr(item) {\n        if (Array.isArray(item)) {\n            for (let key of item) {\n                yield* getArr(key);\n            }\n        } else {\n            yield item;\n        }\n    }\n\n    let arr = [1, [2, [3, 4, 5], 6]];\n    for (let key of getArr(arr)) {\n        //console.log(key);\n    }\n}\n\n\n/**\n * 作为对象属性的Generator函数\n * */\n{\n    let o = {\n        * foo() {\n\n        }\n    }\n}\n\n/**\n * 让Generator函数返回一个正常的对象实例,既可以用next方法,又可以获得正常的this?\n * */\n//  没求用****************************\n{\n    function* F() {\n        \"use strict\";\n        this.a = 1;\n        yield this.b = 2;\n        yield this.c = 3;\n    }\n\n    let obj = {};\n    let f = F.call(obj);\n\n    //console.log(f.next());\n    //  这时的f是遍历器对象,obj是实例\n    //console.log(f, obj);\n}\n\n/**\n * Generator实现状态机\n * */\n{\n    function* toggle() {\n        \"use strict\";\n        while (1) {\n            yield 1;\n            yield 2;\n            if (yield 3) {\n                break;\n            }\n        }\n    }\n\n    let g = toggle();\n    let i = 10;\n    while (i) {\n        //console.log(g.next().value);\n        i--;\n    }\n\n    let button = document.createElement('button');\n    button.innerHTML = 'james';\n    document.body.appendChild(button);\n    button.onclick = function () {\n        //              这个true会改变yield表达式的值\n        var value = g.next(true).value;\n        console.log(value);\n    }\n}"
        },
        {
            "title": "Generator 函数的异步应用",
            "__html": "<h3>传统异步编程</h3>\n<ol>\n    <li>回调函数</li>\n    <li>事件监听</li>\n    <li>发布/订阅</li>\n    <li>Promise对象</li>\n</ol>\n<ol start=\"5\">\n    <li>异步:任务不是连续的,在执行中可能插入了其他任务.</li>\n    <li>回调函数:把任务的第二段单独写在一个函数里,等到重新执行这个任务的时候,直接调用这个函数.</li>\n    <li>Promise:回调函数太多时,会出现多重嵌套,形成强耦合.Promise将嵌套改成链式调用.但是一堆then也只是改变了语法,原来的语义并不清楚.</li>\n</ol>\n<h3>Generator异步调用的基本概念</h3>\n<ol>\n    <li>协程:多个线程相互协作,完成异步任务.</li>\n    <li>yield命令表示执行到此处,执行权将交给其他协程.</li>\n    <li>Generator函数最大的特点就是可以交出函数的执行权.</li>\n    <li>Generator函数还有两个特点:函数体内外的数据交换和错误机制处理.</li>\n    <li>next可以向Generator函数内传参,throw可以向Generator抛出错误.</li>\n</ol>\n<h3>Thunk函数(形实转换程序)</h3>\n<ol>\n    <li>求值策略:1.传值调用,先计算实参,2.传名调用,将实参带入函数.</li>\n    <li>Thunk函数的意义:它是传名调用的一种实现策略.将参数放到一个临时函数中,再将这个临时函数传入函数体.</li>\n    <li>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式.</li>\n</ol>",
            "code": "/**\n * Thunk函数的实现,传明函数的策略\n * */\n{\n    let sum = (x, y) => x + y;\n    let s = sum(1 + 2, 3);\n    console.log(s);\n    //  thunk\n    let thunk = (x) => x;\n    let t = sum(thunk(1 + 2), 3);\n    console.log(t);\n}\n\n\n{\n\n    //var r1 = g.next();\n    //r1.value(fn);\n    function fn(err, data) {\n        if (err) throw err;\n        r1 = g.next(data);\n        r1.value(fn);\n    }\n}\n\n"
        },
        {
            "title": "async 函数",
            "__html": "<h3>async</h3>\n<ol>\n    <li>它就是 Generator 函数的语法糖,使得异步操作变得更加方便.</li>\n    <li>将*换成async,将yield换成await.</li>\n</ol>\n<ol>\n    <li>内置执行器.</li>\n    <li>更好的语义.async表示异步,await表示等待.比yield语义更清晰.</li>\n    <li>更广的实用性.await后面,可以是Promise对象和原始类型的值.</li>\n    <li>返回值是Promise,可以用then方法指定下一步操作.</li>\n</ol>\n<h4>basic use</h4>\n<ol>\n    <li>async返回一个Promise对象,可以使用then方法添加回调函数.遇到await就会先等到异步操作完成,再接着执行函数体内后面的语句.</li>\n    <li>async函数返回的是Promise对象,可以作为await命令的参数.</li>\n</ol>\n<hr>\n<h4>语法</h4>\n<h5>async</h5>\n<ol>\n    <li>async函数返回一个Promise对象.</li>\n    <li>async函数内部return语句返回的值,会成为then方法回调函数的参数.</li>\n    <li>async函数内部抛出错误,会导致返回的Promise对象变成reject状态.</li>\n    <li>async函数返回了一个Promise对象p,p拥有一个实例方法then.这个then方法必须等到async函数内部的每一个await命令后面的Promise对象执行完,才会执行.除非遇到return语句或抛出错误.\n    </li>\n</ol>\n<h5>await</h5>\n<ol>\n    <li>await后面,可能是一个值,这时表达式的值就是这个值.</li>\n    <li>await后面,也可能是一个定义了then方法的对象,那么await将其等同于Promise对象.这个表达式的值视Promise的返回值而定.通常是then方法的返回值.</li>\n    <li>await后面的Promise对象状态变为reject,则reject参数会被async返回的实例的catch方法的回调接受.且中断整个async函数.</li>\n    <li>如果希望前一个await后的Promise对象的状态即使reject,也不中断后续await,则需要将它放在try...catch语句中.</li>\n    <li>由于Promise对象在执行实例的catch后,会返回一个新的实例,这个实例的状态通常是resolve,则我们可以在这个状态可能会变成reject的实例后面加上catch方法,以防止中断async函数.</li>\n</ol>\n<h5>错误处理</h5>\n<ol>\n    <li>如果await后面的异步操作出错,那么等于async函数返回的Promise对象的状态被置为reject.</li>\n</ol>\n<h5>使用注意点,优化</h5>\n<ol>\n    <li>await只能用在async函数中.esm模块加载器支持顶层await</li>\n    <li>await命令后面的Promise对象,状态可能是reject,所以最好把await放在try...catch语句中.</li>\n    <li>多个await命令后面的异步操作,如果不存在继发关系,最好让它们同时触发,可以使用Promise.all.</li>\n    <li>async函数可以保留运行堆栈.在内部有一个异步函数时,如果它报错,他的错误堆栈将包括async函数.普通函数则不被包含.</li>\n</ol>\n<h5>async 函数的实现原理</h5>\n<ol>\n    <li>async函数的实现原理,就是讲Generator函数和自动执行器,包装在一个函数里.</li>\n</ol>\n<h5>与其他异步处理方法的比较</h5>\n<ol>\n    <li>Promise写法比回调函数有改进,但代码全是then,catch,语义不明确.</li>\n    <li>Generator遍历了每个步骤,语义清晰.问题是必须有一个任务运行器去执行Generator对象.</li>\n    <li>async函数简洁,相比Generator,可以自执行.</li>\n</ol>\n<h4>异步遍历器</h4>\n<ol>\n    <li>Iterator接口是一种数据遍历协议,只要调用遍历器对象的next方法,就会得到一个对象,表示当前遍历指针所在的那个位置的信息.</li>\n    <li>异步遍历器最大的特点,调用next方法,返回一个Promise对象.</li>\n</ol>",
            "code": "{\n    //const asFn = async function () {\n    //    const f1 = await Promise(function (resolve, reject) {\n    //        resolve()\n    //    });\n    //    const f2 = await function () {\n    //        return 2;\n    //    };\n    //};\n    //let a = asFn();\n    //a.then(function (resolve) {\n    //    console.log(resolve)\n    //});\n}\n\n{\n    //  async实现异步编程,强!无敌!\n    function timeout(ms) {\n        return new Promise((resolve) => {\n            setTimeout(function () {\n                resolve(`???`);\n            }, ms);\n        });\n    };\n\n    async function asyncPrint(value, ms) {\n        let a = await timeout(ms).then(function (res) {\n            console.log(res);\n            return 'then已经执行完了';\n        });\n        //console.log(a);\n        await timeout(ms);\n        console.log(a, value);\n    };\n    //asyncPrint('james', 300);\n}\n{\n    async function timeout(ms) {\n        var p = await new Promise((resolve) => {\n            setTimeout(function () {\n                resolve('promise');\n            }, ms)\n        }).then(function (res) {\n            console.clear();\n            console.log(`res:${res}`);\n            return 'then已经执行完了';\n        });\n        return p;\n    };\n\n    async function asyncPrint(ms) {\n        let a = await timeout(ms);\n        console.log(a);\n        return a;\n    };\n    //var p = asyncPrint(333);\n    //p.then(function (res) {\n    //    console.log(res);\n    //});\n}\n\n/**\n * 语法\n * */\n{\n    //  async函数返回Promise对象\n    async function f() {\n        if (Math.random() > 0.5) {\n            throw new Error('async函数内部报错,会执行catch方法.');\n        }\n        return 'async函数的返回值';\n    };\n    (function () {\n        return;\n        let af = f().then(resolve => {\n            console.log(`${resolve},会成为then方法的then方法的参数`);\n        }).catch(function (reject) {\n            console.log(`${reject}`)\n        });\n        console.log(af);\n    }());\n}\n{\n    //  async返回的Promise对象的then方法,必须等到async函数内部的每一个await后面的Promise对象执行完,才发生状态改变\n    async function f() {\n        \"use strict\";\n        await new Promise(resolve => {\n            setTimeout(function () {\n                resolve(123)\n            }, 333);\n        });\n        return '这个返回值就是async的实例的then函数的实参.';\n    };\n    (function () {\n        return;\n        let af = f().then(resolve => console.log(`${resolve}:async函数内部的await后面的Promise执行完.`));\n        console.log(af);\n    }());\n}\n{\n    //  await后面应该是一个promise对象,如果不是,则返回对应的值\n    async function f() {\n        let a = await '值';\n        let b = await new Promise((resolve, reject) => {\n            resolve('promise');\n        }).then(resolve => 1);\n        return (Math.random() > 0.5) ? a : b;\n    };\n    let af = f();\n    //af.then(console.log);\n}\n{\n    //  await后面的promise对象的状态变成reject,则会被await返回的promise实例的catch方法捕捉\n    async function f() {\n        await Promise.reject('await后面的promise的状态为reject');\n        await Promise.resolve('前一个await后面的Promise的实例状态是reject,所以我不执行')\n    }\n\n    //f().catch(console.log);\n}\n\n{\n    //  错误处理\n    //  await后面的异步操作出错下:async返回的Promise实例的状态被置为reject\n    async function f() {\n        await new Promise(function (resolve, reject) {\n            throw new Error('出错了');\n        });\n\n        //  统一放在try...catch中\n        try {\n            await new Promise(function (resolve, reject) {\n                throw new Error('出错了');\n            });\n            await new Promise(function (resolve, reject) {\n                throw new Error('出错了');\n            });\n            await new Promise(function (resolve, reject) {\n                throw new Error('出错了');\n            });\n        } catch (err) {\n\n        }\n    };\n    //f().catch(console.log);\n}\n\n//  使用注意点,优化\n{\n    //  如果多个await命令后的异步操作没有继发关系,则最好让它们同时触发\n    function getA() {\n        return new Promise(function (resolve) {\n            resolve('getA完成');\n        })\n    };\n\n    function getB() {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                resolve('getB完成');\n            }, 333);\n        })\n    }\n\n    async function f() {\n        return await Promise.all([getA(), getB()]);\n    }\n\n    //f().then(console.log)\n}\n\n\n/**\n * 实例:按顺序执行异步操作\n * 读取一组 URL，然后按顺序输出.\n * */\n/**\n * 这是promise,所以复杂!!\n * */\n{\n    function logInOrder(urls) {\n        //  读取\n        const textPromise = urls.map(url => {\n            /**\n             *每个fetch操作都返回一个 Promise 对象\n             * */\n            return new Promise(function (resolve) {\n                setTimeout(function () {\n                    resolve(1)\n                }, Math.random() * 1111)\n            }).then(function (r) {\n                return fetch(url).then(response => response.text());\n            });\n        });\n        //  输出\n        textPromise.reduce((chain, current) => {\n            return chain.then(() => current)\n                .then(text => {\n                    console.log(text.substr(0, 20))\n                });\n        }, Promise.resolve());\n    };\n    //logInOrder([encodeURIComponent('./async 函数.js'), encodeURIComponent('./Class 的基本语法.js'), location.href]);\n}\n\n//  async\n{\n    async function logInOrder(urls) {\n        for (let url of urls) {\n            var text = (await fetch(url)).text();\n            var str = (await text).substr(0, 50);\n            console.log(str);\n        }\n    };\n    logInOrder([encodeURIComponent('./async 函数.js'), encodeURIComponent('./Class 的基本语法.js'), location.href]);\n}\n//  方法2.因为上面的方法有个缺点,在一个async函数里执行多个await,是阻断执行的.\n//  改进方法,让他们可以异步执行.\n//  思路:map一个arr,map出来urls的Promise对象,然后再for...of遍历这个arr\n{\n    async function logInOrder(urls) {\n        let arr = urls.map(async url => {\n            let response = await fetch(url);\n            let text = await response.text();\n            console.log(text.substr(0, 40), new Date().getTime());\n            return text;\n        });\n        return arr;\n    };\n    logInOrder([encodeURIComponent('./async 函数.js'), encodeURIComponent('./Class 的基本语法.js'), location.href]);\n    //list.then(response=>console.log(response));\n}"
        },
        {
            "title": "Class 的基本语法",
            "__html": "<h3>Class</h3>\n<ol>\n    <li>es6的class只是一个语法糖,大部分功能es5都能实现.新的class写法只是让原型的写法更加清晰,更像面向对象语法.</li>\n    <li>方法之间不需要逗号分隔.</li>\n    <li>类的所有方法都定义在prototype上面.</li>\n    <li>类的内部所有定义的方法,都是不可枚举的.</li>\n</ol>\n<h4>constructor方法</h4>\n<ol>\n    <li>constructor方法是默认方法,通过new命令生成对象实例时,自动调用该方法.</li>\n    <li>每一个class都必须有一个constructor方法,如果没有显示定义,则添加一个空的constructor.</li>\n    <li>constructor默认返回this,也可以指定返回另一个对象,但这样会导致实例对象不是class的实例.</li>\n</ol>\n<h4>类的实例</h4>\n<ol>\n    <li>必须使用new调用,否则报错.</li>\n    <li>实例的属性除非显示的定义在其本身,就是this.a=b的形式,否则都是定义在原型上.</li>\n</ol>\n<h4>取值函数（getter）和存值函数（setter）</h4>\n<ol>\n    <li>类的内部可以使用get和set关键字,对某个属性设置存值函数和取值函数,拦截该属性的存取行为.</li>\n    <li>存值函数和取值函数是设置在属性的Descriptor对象上的.</li>\n</ol>\n<h4>属性表达式</h4>\n<ol>\n    <li>类的属性名,可以采用表达式.</li>\n</ol>\n<h4>Class表达式</h4>\n<ol>\n    <li>与函数一样,类也可以使用表达式.</li>\n</ol>\n<h4>注意点</h4>\n<ol>\n    <li>类和模块的内部,默认是严格模式.这是为了考虑未来的代码都在模块中运行,所以把整个语言升级到了严格模式.</li>\n    <li>不存在声明提升.</li>\n    <li>函数的许多特性都被class继承,包括name属性.name属性是指class关键字后面的标识符.</li>\n    <li>给某个方法前加上*,就表示一个Generator方法.</li>\n    <li>this的指向默认指向实例.</li>\n</ol>\n<h4>静态方法</h4>\n<ol>\n    <li>在类中定义的方法会传递给实例.但如果在一个方法前加上static关键字,就表示这个方法不会被继承,而是直接通过类来调用,这就是静态方法.</li>\n    <li>如果静态方法里有this关键字,它指向class而不是实例.</li>\n    <li>静态方法可以和类方法重名.</li>\n    <li>父类的静态方法,可以被子类继承.</li>\n</ol>\n<h4>实例属性的新写法</h4>\n<ol>\n    <li>实例属性除了定义在constructor,也可以定义在类的最顶层.</li>\n</ol>\n<h4>静态属性</h4>\n<ol>\n    <li>class本身的属性,不是定义在实例上.</li>\n</ol>\n<h4>私有方法和私有属性</h4>\n<ol>\n    <li>只能在内部访问的方法和属性,外部不能访问.es6通过变通方法实现.</li>\n    <li>方式:将私有方法移出模块.利用Symbol值的唯一性.</li>\n</ol>\n<h4>new.target属性</h4>\n<ol>\n    <li>用于在构造函数中,返回new命令作用于的那个构造函数.就是new 了谁.</li>\n    <li>可以用来确定构造函数是如何被调用的.</li>\n    <li>Class 内部调用new.target,返回当前 Class.</li>\n</ol>",
            "code": "{\n    class Point {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        toString() {\n            return `${this.x},${this.y}`;\n        }\n    }\n\n    //console.log(new Point(1, 2));\n    //console.log(typeof Point);\n    //console.log(Point.prototype);\n    //console.log(Point === Point.prototype.constructor);\n}\n{\n    class Bar {\n        doStuff() {\n            console.log(this, '在class里定义的方法都在prototype上面.都是不可枚举的.');\n        }\n    }\n\n    Object.assign(Bar.prototype, {\n        toString() {\n        },\n        toValue() {\n        }\n    });\n\n    var b = new Bar();\n    //b.doStuff();\n    //console.log(Reflect.ownKeys(b.constructor.prototype));\n    //console.log(Object.keys(b.constructor.prototype))\n}\n\n//  constructor方法\n{\n\n}\n//  类的实例\n{\n    class A {\n        setProperty(x) {\n            this.name = x;\n        }\n    }\n\n    let a = new A;\n    a.setProperty('123');\n    //console.log(a);\n}\n\n//  取值函数（getter）和存值函数（setter）\n{\n    class M {\n        constructor() {\n\n        }\n\n        get prop() {\n            return 'getter';\n        }\n\n        set prop(val) {\n            console.log(`setter:${val}`);\n        }\n    }\n\n    let m = new M;\n    //m.prop = 123;\n    //console.log(m.prop);\n    let descriptor = Object.getOwnPropertyDescriptor(m.constructor.prototype, 'prop');\n    //console.log(descriptor);\n}\n//  属性表达式\n{\n    let methodName = 'getArea';\n\n    class Square {\n        [methodName]() {\n            console.log(methodName);\n        }\n    }\n\n    //new Square() [methodName]();\n}\n\n//  class表达式\n{\n    class M {\n    }\n\n    const MyClass = M;\n    //console.log(MyClass, '\\n', M);\n    //console.log((new MyClass).constructor.prototype === (new M).constructor.prototype);\n\n    let A = class B {\n    };\n    //console.log(A.name);\n}\n\n//  generator\n{\n    class A {\n        _getName() {\n            return 'james';\n        }\n\n        * [Symbol.iterator]() {\n            for (let key of Object.getOwnPropertyNames(this.constructor.prototype)) {\n                yield key;\n            }\n        }\n    }\n\n    for (let x of new A()) {\n        //console.log(x);\n    }\n}\n\n//  this的指向\n{\n    class A {\n        setName(val) {\n            if (this) {\n                this.setProperty('name', val);\n            } else {\n                console.log('这个this是undefined');\n            }\n        }\n\n        setProperty(key, val) {\n            this[key] = val;\n        }\n    }\n\n    let a = new A();\n    a.setName('james');\n    let {setName} = a;\n    //setName('pierce');\n\n}\n//  this绑定,实例方法\n{\n    class A {\n        constructor() {\n            this.setName = this.setName.bind(this);\n        }\n\n        setName(val) {\n            if (this) {\n                this.setProperty('name', val);\n            } else {\n                console.log('这个this是undefined');\n            }\n        }\n\n        setProperty(key, val) {\n            this[key] = val;\n        }\n    }\n\n    let a = new A;\n    let {setName} = a;\n    //setName('james');\n    //console.log(a);\n}\n//  this绑定,箭头函数\n{\n    class A {\n        constructor() {\n            this.setName = (val) => {\n                this.setProperty('name', val);\n            }\n        }\n\n        setProperty(key, val) {\n            this[key] = val;\n        }\n    }\n\n    let a = new A;\n    let {setName} = a;\n    setName('james');\n    //console.log(a);\n}\n\n/**\n * 静态方法\n * */\n{\n    class A {\n        static getName() {\n            console.log()\n            return this.name;\n        }\n    }\n\n    //console.log(new A().getName);\n    //console.log(A.getName());\n}\n\n/**\n *实例属性新写法\n * */\n{\n    //class foo {\n    //    bar = 'hello';\n    //    baz = 'world';\n    //}\n    //new foo()\n}\n\n/**\n * 静态属性\n * */\n{\n    class A {\n        //static b=1;\n    }\n}\n\n/**\n * 私有方法和私有属性\n * */\n//  下划线表示这时一个只限于内部使用的私有方法.但并不保险.\n{\n    class A {\n        a(b) {\n            this._b(b);\n        }\n\n        _b(b) {\n            return this.b = b;\n        }\n    }\n\n}\n//  将私有方法移出模块\n{\n    class A {\n        a(b) {\n            c.call(this, b);\n        }\n    }\n\n    function c(val) {\n        return this.b = val;\n    }\n\n    let a = new A();\n    a.a(1234);\n    //console.log(a);\n}\n//  利用Symbol值的唯一性\n{\n    class A {\n        [Symbol('123')]() {\n            return 1;\n        }\n    }\n\n    console.log(new A());\n}"
        },
        {
            "title": "Class 的继承",
            "__html": "<h3>class继承</h3>\n<h4>强!无敌!!</h4>\n<ol>\n    <li>class可以通过extends关键字实现继承.它比es5更清晰,简单,方便.</li>\n    <li>super关键字表示父类的构造函数,用来新建父类的this对象.</li>\n    <li>子类必须在constructor方法中调用super方法,因为子类的this对象必须先通过父类的构造函数完成塑造,得到父类相同的属性和方法,然后再加上子类的属性和方法.否则无法得到this对象.</li>\n    <li>es5的继承,实例先创造子类的this,在将父类的方法添加到this对象.</li>\n    <li>es6的继承,先创建父类实例对象的属性和方法,然后添加到this对象,再用子类构造函数修改this.</li>\n    <li>这就是说,子类的实例基于父类实例,只要调用super方法后,才能使用this.</li>\n    <li>父类的静态方法,也会被子类继承.</li>\n</ol>\n<h4>Object.getPrototypeOf()</h4>\n<ol>\n    <li>从子类上获取父类.子类实例的原型是父类实例.</li>\n</ol>\n<h4>super关键字</h4>\n<ol>\n    <li>super关键字,既可以当函数使用,也可以当对象使用.</li>\n    <li>当作函数调用时,代表父类的构造函数.虽然代表父类构造函数,但父类构造函数的this指向子类的this.</li>\n    <li>作为对象时,在普通方法中,指向父类的原型,在静态方法中,指向父类.</li>\n    <li>无法通过super调用定义在父类实例上的属性或方法.</li>\n    <li>通过super调用父类方法时,父类方法的this指向子类实例.相当于super.a.call(this).</li>\n    <li>同理,super调用父类静态方法时,父类静态方法的this指向子类.</li>\n    <li>对象都是继承其他对象的,所以可以在任何对象中,使用super关键字.</li>\n</ol>\n<hr>\n<h4>类的 prototype 属性和__proto__属性</h4>\n<p class=\"red\">是对于类,不是实例</p>\n<ol>\n    <li>typeof A === 'function',所以:</li>\n    <li>__proto__表示构造函数的继承,总是指向父类.</li>\n    <li>prototype.__proto__属性,表示方法的继承,总是指向父类的prototype.</li>\n    <li>class B extends A,则B.__proto__ === A;B.prototype.__proto__ === A.prototype.</li>\n    <li>class A,则A.__proto__ === Function.prototype;A.prototype.__proto__ ===\n        Object.prototype.A作为一个基类,就是一个普通函数,直接继承Function.prototype.\n    </li>\n</ol>\n<p class=\"red\">对于实例</p>\n<ol>\n    <li>子类实例的__proto__指向子类的原型对象.</li>\n    <li>子类实例的__proto__的__proto__指向父类的原型对象.</li>\n</ol>\n<h4>原生功能构造函数的继承</h4>\n<ol>\n    <li>es6允许继承原生构造函数定义子类,因为es6是先新建父类的实例对象this,然后再用子类的构造函数修饰this,使得父类的所有行为可以被继承.</li>\n    <li>extends关键字,不仅可以继承类,还可以继承原生的构造函数.</li>\n    <li>继承Object的子类,有一个行为差异.一旦Object方法不是通过new Object形式调用,则会忽略参数.</li>\n</ol>",
            "code": "{\n    class A {\n\n    }\n\n    class B extends A {\n\n    }\n\n    //console.log(new B(1));\n}\n\n//  子类的constructor中必须通过super方法去调用父类的构造函数,否则子类无法得到this对象\n//  子类调用super后,才会创建this对象,所以必须先super\n{\n    class A {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        toString() {\n            return '这是A';\n        }\n    }\n\n    class B extends A {\n        constructor(x, y, color) {\n            super(x, y);\n            this.color = color;\n        }\n\n        toString() {\n            return this.color + ',' + super.toString();\n        }\n    }\n\n    let b = new B(2, 3, 'red');\n    //console.log(b, b.toString(), b instanceof A, b instanceof B);\n}\n\n//  父类的静态方法也会被子类继承\n{\n    class A {\n        static a() {\n            return 1;\n        }\n    }\n\n    class B extends A {\n\n    }\n\n    //console.log(B.a());\n}\n\n/**\n * Object.getPrototypeOf()\n * */\n{\n    class A {\n    }\n\n    class B extends A {\n    }\n\n    //console.log(Object.getPrototypeOf(new A), Object.getPrototypeOf(new B));\n}\n\n/**\n *super关键字\n * */\n//  super作为函数\n{\n    class A {\n        constructor() {\n            //  this指向子类实例\n            console.log(this, new.target.name)\n        }\n    }\n\n    class B extends A {\n        constructor() {\n            super()\n        }\n    }\n\n    //console.log(new B);\n}\n//  super作为对象\n{\n    class A {\n    }\n\n    class B extends A {\n        static way() {\n            console.log('指向父类');\n            return super.constructor;\n        }\n\n        way() {\n            console.log('指向父类原型');\n            return super.constructor;\n        }\n    }\n\n    //console.log(B.way());\n    //console.log(new B().way());\n}\n//  无法通过super调用父类实例的属性或方法.\n{\n    class A {\n        constructor() {\n            this.p = 'p';\n        }\n\n        get q() {\n            return 'q';\n        }\n\n        static get t() {\n            return 't';\n        }\n\n    }\n\n    class B extends A {\n        get m() {\n            return super.p;\n        }\n\n        get n() {\n            return super.q;\n        }\n\n        static get s() {\n            return super.t;\n        }\n    }\n\n    let b = new B();\n    //console.log(`m:${b.m},n:${b.n},s:${B.s}`);\n}\n//  通过super调用父类方法时,父类的this指向子类实例\n{\n    class A {\n        constructor() {\n            this.a = 'a';\n        }\n\n        getA() {\n            return this.a;\n        }\n    }\n\n    class B extends A {\n        constructor() {\n            super();\n            this.a = 'b';\n        }\n\n        getB() {\n            return super.getA();\n        }\n    }\n\n    //console.log(new B);\n    //console.log(new A().getA(), new B().getB());\n}\n\n/**\n * 类的.__proto__\n * */\n{\n    class A {\n    }\n\n    class B extends A {\n    }\n\n    //console.log(B.__proto__, A);\n    //console.log(B.prototype, B.prototype.__proto__, A.prototype);\n}\n//  相当于\n{\n    class A {\n    }\n\n    class B {\n    }\n\n    Object.setPrototypeOf(B, A);\n    Object.setPrototypeOf(B.prototype, A.prototype);\n    //console.log(B.__proto__, A);\n    //console.log(B.prototype, B.prototype.__proto__, A.prototype);\n}\n\n//  子类实例的__proto__\n{\n    class A {\n    }\n\n    class B extends A {\n    }\n\n    //console.log(new B().__proto__, B.prototype);\n    //console.log(new B().__proto__.__proto__, A.prototype);\n}\n\n\n/**\n *原生构造函数的继承\n * */\n{\n    class MyArray extends Array {\n        constructor() {\n            super();\n            this.history = [[]];\n        }\n\n        commit() {\n            this.history.push(this.slice());\n        }\n\n        revert() {\n            if (this.history.length) {\n                this.splice(0, this.length, ...this.history[this.history.length - 1]);\n                this.history.pop();\n            }\n        }\n    }\n\n    let arr = new MyArray();\n    for (let i = 0; i < 10; i++) {\n        arr.push(i);\n        arr.commit();\n    }\n    arr.revert();\n    arr.revert();\n    arr.revert();\n    arr.revert();\n    arr.revert();\n    //console.log(arr);\n}\n\n/**\n * mixin模式\n * */\n{\n    function mix(...mixins) {\n        class Mix {\n        }\n\n        for (let mixin of mixins) {\n            copyProperty(Mix.prototype, mixin);\n            copyProperty(Mix.prototype, Reflect.getPrototypeOf(mixin));\n        }\n        return Mix;\n    }\n\n    function copyProperty(target, source) {\n        for (let key of Reflect.ownKeys(source)) {\n            if (key !== 'constructor'\n                && key !== 'prototype'\n                && key !== 'name') {\n                Object.defineProperty(target, key,\n                    Object.getOwnPropertyDescriptor(source, key));\n            }\n        }\n    }\n\n    class DistributedEdit extends mix({'ncaa': '不好用,意义不明,看看就行.'}) {\n    }\n\n    let distributededit = new DistributedEdit();\n    console.log(distributededit, distributededit.ncaa)\n}"
        },
        {
            "title": "修饰器",
            "__html": "<h4>类的修饰</h4>\n<p>修饰器是一个对类进行处理的函数,如果一个参数不够用,可以在外面再封装一层函数</p>\n<p>修饰器本质是编译时执行的函数</p>\n<p>参数:类</p>\n<h4>方法的修饰</h4>\n<p>参数:原型,名字,描述对象</p>\n<p>修饰器有注释的作用</p>",
            "code": "(() => {\n    class Math {\n        add(a, b) {\n            return a + b;\n        }\n    }\n\n    function log(target, name, descriptor) {\n        var oldValue = descriptor.value;\n\n        descriptor.value = function () {\n            console.log(`Calling ${name} with`, arguments);\n            return oldValue.apply(this, arguments);\n        };\n\n        return descriptor;\n    }\n\n    const math = new Math();\n\n// passed parameters should get logged now\n    math.add(2, 4);\n})();\n\n\n(() => {\n    \"use strict\";\n    const Foo = {\n        foo() {\n            console.log('foo')\n        }\n    };\n\n    class MyClass {\n    }\n\n    Object.assign(MyClass.prototype, Foo);\n\n    let obj = new MyClass();\n    obj.foo(); // 'foo'\n    console.log(MyClass)\n})();\n\n(() => {\n    \"use strict\";\n\n    function log(target) {\n        console.log(target)\n    }\n\n    class A {\n\n    }\n\n    let a = new A;\n\n})();\n"
        }
    ]
}
